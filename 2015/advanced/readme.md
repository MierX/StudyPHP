#   PHP核心编程及MySQL数据库加强
    该部分需要学习24天
##  01
    开始第一天的学习
### php介绍、php脚本模式
    php：Personal Home Page => HypeText Preprocessor
    历史：
        1995PHP/FI,Rasmus LorderfmPersonal Home Page
        1997PHP/FI2.0
        1998PHP3
        2000PHP4
        2005PHP5
    应用领域：
        web服务器端脚本（主要领域）
        命令行脚本
            运行php文件：php.exe -f "php文件路径"
            运行php文件：php.exe -f "php脚本代码"
        应用程序图形界面
### web服务器运行模式及相关技术（软件）
    Web软件的运行模式中，总是现在客户端（浏览器），发起一个“请求”，然后，服务器端才产生反馈动作（运行程序），并因此而返回给该浏览器一定的信息（响应）
### php网页运行原理
    看视频
### apache的安装
    看视频
### 配置apache以运行php代码
    看视频
### php配置 —— 时区配置
    看视频
### php配置 —— 模块配置
    php.ini是apache的众多模块之一
    mysql.ini是php的众多模块之一
### MySQL的安装与配置
    看视频
### 单站点配置
    看视频
### 目录访问权限（包括分布式权限）
    一个站点就是一个目录
    每个目录，都应该给其设定“访问权限”，语法如下
    <Directory "要设置权限的目录路径">
        #   设置当一个请求中没有给定请求的文件名又没有默认网页（首页）的时候，显示文件列表
        Options Indexes
        
        #   设置权限控制的先后顺序，只有两种：
                Deny,Allow（先拒绝，后允许）
                Allow,Deny（先允许，后拒绝）
        Order Deny,Allow
        
        #   Deny用于设定拒绝访问的来源地址或服务器名，几乎没有实际意义
        Deny from 拒绝名单 
            比如：deny from 192.168.3.8
        Allow from 允许名单
        
        #   设置该文件夹下的“默认网页”（首页），可以设置多个，用于请求中不带文件名的时候用该文件作为响应页面
        DirectoryIndex index.php index.html main.php
    </Directory>
    
    对于某个目录的访问权限，我们在apache中使用Directory来设定，但可能不够方便：
        apache配置修改后，必须重启apache
        某个站点中的“下级目录”访问权限，不方便单独设置
    这种，可以成为“集中式权限”：
    分布式权限：就是针对某个网站的任何一个下级目录，都可以单独去设置其访问权限，并且可以不重启apache就生效：
    # AllowOverride表示当前目录，允许“分布式”权限配置
    AllowOverride all
    #   在该目录下的任何子目录中，创建一个特殊的文件（.htaccess），在该文件中写所需要的“权限内容”（几乎与Directory的写法一样）
    Deny from all
    Allow from 192.168.3.4
### 多站点配置
    在apache的主配置文件httpd.conf中，“打开”多站点虚拟主机配置文件项（httpd-vhosts.conf）
    设定希望提供“多站点”服务的IP地址和端口号，通常默认就是：*:80，其中“*”代表所有IP在http-vhosts.conf文件中，默认其实apache安装好之后就设置好了，无需手动设置（关键字：NameVirtualHost）
    然后就一个站点一个站点加上，形式如下：
        <virtualhost *:80>
            #   设置站点1的各项信息
        </virtualhost>
    注意：
        先把httpd-vhosts.conff文件中的2个初始安装生成的站点删除
        每个站点的设置项，主要就3个：
            ServerName
            DocumentRoot
            <Directory>...</Directory>
        在多站点配置中，第一个站点被称为“默认站点”，如果某个请求的域名无法跟任何一个站点匹配，就当作默认站点
### 虚拟目录的设置
    某个站点所对应文件夹下有一个目录为d1，直接访问这个目录名则为真实目录
    该站点不存在某目录名，但可以同样访问该目录名就是虚拟目录
    
    设置目录别名的名字和其对应的“实际真实目录（文件夹位置）”
        Alias /目录别名的名字 “实际真实目录的位置”
    设置该真实目录的访问权限（否则是禁止访问的）
        <Directory “真实目录路径”>...</Directory>
##  02
    开始第二天的学习
### day1复习
    看视频
### day1作业
    看视频
### php的标记形式
    PHP基本语法形式
        php的标记符：
            <?php ... ?>（推荐）
            <script language="php"> ... </script>
            <? ... ?>（不推荐，依赖于php.ini的一个设置项short_open_tag = on，需要打开）
### php的基本语法规定
    php的结束标记：
        ?>：（纯php文件中，可以省略）
    php的区分大小写特性
        变量区分大小写
        常量通常默认也区分，但可以人为设定不区分
        其他场合的关键字都不区分
    php的注释
        单行注释：
            // 注释内容
            # 注释内容
        多行注释：
            /* 注释内容 */
### 变量的基本理解
    基本理解：
        变量可以理解为只是一个代表一定存储空间及其中数据的一个标识符
### 变量的基本操作
    基本操作：
        赋值：
            等号（=）的左边放变量名，右边放“数据”
        取值：
            任何需要一个数据的语句中使用一个变量
        判断：
            isset(变量)：判断变量是否存在或是否有数据值
        删除：
            删除一个变量，并不是指将该变量从程序中删掉，而是清除变量存储的数据
### 变量命名规则
    常见的命名法：
        驼峰命名法：
            首单词全小写，其后每个单词的首字母大写：$myName
        帕斯卡命名法：
            每个单词的首字母大写：$MyName
        下划线分割法：
            每个单词小写，并且用下划线隔开：$my_name
### 传值方式
    变量的传值方式，是指“一个变量，传给另一个变量”的内部细节形式 —— 单对单
    变量的传值方式，只有两种：
        值传递：
            $v = 1;
            $a = $v;
            将v的数据从存储空间中取出复制一份存放进a的存储空间中
        引用传递：
            $v = 1;
            $a = &$v;
            将a的存储空间地址设置为v的存储空间地址，两个变量共用一个数据
### 可变变量
    $abc = 1;
    $v = 'abc';
    $$v === $abc // true
### 预定变量综述
    预定义变量是php预先定义好的变量
    主要有：
        $_GET
        $_POST
        $_REQUEST
        $_SERVER
        $GLOBALS
    以上都是数组类型
    系统定义与维护 —— 不应赋值或销毁变量，只是拿来使用
    具有超全局作用域 —— 任何范围都可以使用
    不同情形下可能具有不同的值
### post变量
    $_POST：
        它代表用户通过表单提交的时候所提交的所有数据
    isset(变量)：判断变量是否存在或是否为空
    empty(变量)：判断变量的内容是否为空
### 计算器案例
    看视频
### get变量
    代表用户通过get方式提交数据
    有4种get提交方式：
        方式1：
```html
            <from action="目标文件.php" method="get">
                <input type="text">
                <input type="text">
                <input type="text">
            </from>
```
            这种形式的get数据，跟post数据类似，数据内容由用户填写或选择而得到！
        方式2：
            <a href="目标文件.php?name=value"></a>
            它只是一个链接，只是在链接文件名后面加上“？”，然后拼上数据
            数据形式为：数据名称=数据值，数据之间用“&”拼接
            这种形式的数据也同样是提交的get数据，用户无法改变数据
        方式3：
            <script>
                location.href = "目标文件.php?name=value";
            </script>
            该语句可以看作是通过js技术实现的页面跳转功能
            起哄该语句，通常都是放在一个函数中，因为某个事件被触发
        方式4：
            <script>
                location.assign('目标文件.php?name=value');
            </script>
        方式5：
             <?php
                header("location: 目标文件.php?name=value")
             ?>
### get数据获取
    看视频
### request变量
    看视频
### SERVER变量
    看视频
### GLOBALS变量
    看视频
##  03
### day2复习
    看视频
### day2作业
    看视频
### 常量的定义和基本使用
    常量是相对于变量来说的：是一个其中存储的数据不会应不能改变的“标识符”
    常量的使用：定义、取值
    常量的定义：
        define('常量名', '值');
        const 常量名 = 值;
### 常量的其他细节
    常量与变量的区别：
        定义形式不同
        实用形式不同：常量不需要$符号
        可变程度不同：常量的值不可以改变，常量也不可以销毁
        作用范围不同：常量具有超全局作用域（函数内外都可以直接使用）
        可用类型不同：常量只能存储标量类型（整数、浮点数、字符串、布尔）
    判断常量是否存在：defined()函数，返回bool值
    使用一个未定义的常量：
        在php中，当使用一个未定义的常量的时候，系统会直接将该常量当作有值的常量去使用，并且其值就是该常量名（系统同时会报警告性错误）
    预定义常量：
        就是系统中预定义好的一些常量，大约有几百个
        M_PI：圆周率
        PHP_OS：php运行所在的操作系统
        PHP_VERSION：php版本号
        PHP_INT_MAX：php中最大的整数值
    魔术常量：
        其实只是常量的形式，但没有常量“恒常”的含义，其值其实会变化的，只是很少的几个：
            __FILE__：当前网页文件
            __DIR__：当前网页文件所在的目录
            __LINE__：当前这个常量名所在的行号
### 数据类型总体划分
    八种数据类型：
        基本类型（标量类型）：
            整数类型：int integer
            浮点数类型：float double
            字符串类型：string
            布尔类型：bool boolean
        复合类型：
            数组：array
            对象：object
        特殊类型：
            空类型：null
            资源类型：resource
### 进制转换的系统函数1
    整数类型：
        整数类型的3种写法：
```php
            $n1 = 123;
            $n2 = 0123; // 八进制数字写法
            $n3 = 0x123; // 十六进制数字写法
            $n4 = 0b1010; // 二进制数字写法
```
    进制转换问题：
        bin：2进制
        oct：8进制
        dec：10进制
        hex：16进制
    进制转换主要分2种情况：
        10进制转换为其它进制：
            10转2：decbin()
            10转8：decoct()
            10转16：dechex()
        其它进制转换为10进制：
            2转10：bindec()
            8转10：octdec()
            16转10：hecdec()
### 进制转换的系统函数2
    看视频
### 进制基础知识
    看视频
### 十进制转换为其他进制
    看视频
### 其他进制转换为十进制
    看视频
### 浮点数的两种表现形式
    浮点数的2种表现形式“
        常规写法：$v1 = 123.456;
        科学计数法：123.456E3
### 整数的细节深入知识
    浮点数使用的细节知识：
        浮点数不应进行大小比较
        小数转2进制的做法：乘2并顺序取整数部分
        当整数运算的结果超出整数的范围后，会自动转换为浮点数
### 字符串
    字符串形式：
```php
        $str1 = '字符串';
        $str2 = "字符串";
$str3 = <<<"A"
字符串
A;
$str4 = <<<A
字符串
A;
//
```
### 布尔类型
    只有两个数据：true、false
    只有如下数据是被当作“假”（false）：
        0，0.0，""，"0"，null，array()，false，未定义的变量
    其余都是真
### 自动类型转换
    自动转换：
        在任何运算中，如果需要某种类型的数据，而给出的数据不是该类型，通常都会发生自动转换，将该类型转换为目标需要的类型
        是由“运算符”或类似运算符的语句来决定的
### 强制转换
    强制转换：
        形式：(目标类型)数据
        含义：将该数据转换为设定的目标类型
        通常：
            (int)
            (string)
            (float)
            (bool)
            (array)
        上述强制类型转换，并不改变该变量的本身数据或类型，对应有一个函数是直接改变变量的类型：
            settype(变量, '类型');
### 有关类型的系统函数
    类型相关的函数：
        var_dump()：用于输出变量的“完整信息”，几乎只用于调试代码
        getType()：获取该变量的类型名字
        setType()：将变量强制改变为目标类型
        isset()：
        empty()：
        unset()：
        is_xx类型系统函数：判断某个数据是否为某种类型
##  04
    学习第四天的知识
### day3复习
    看视频
### day3作业
    看视频
### 算术运算符：基本、字符串自增
    基础：
        符号有：
            +
            -
            *
            /
            %
        说明：
            他们都是针对数字进行运算
            如果存在不是数字的数据，就会自动转换为数字
            其中取余运算（取模）%，它只针对整数进行运算，如果不是整数会自动截取为整数
    自增自减运算符：
        ++
        --
        常规：对数字进行自加1或减1
        字符串：只能自增，效果就是下一个字符
        布尔值递增递减无效
        null递减无效，递增结果为1
### 自加运算
    看视频
### 比较运算符基本0 
    符号：
        >
        >=
        <
        <=
        ==
        !=
        ===
        !==
    一般比较：是针对数字进行的大小比较
    ==和===比较：前者通常叫做模糊相等的比较，后者叫做精确相等的比较（只有数据的类型和数据的值都相等，才是全等的）
    不要对浮点数直接进行大小比较
### 不同类型数据之间的比较
    如果比较的数据中，有布尔值，转为布尔值比较，true > false
    有数字值，就转为数字值比较
    两边都是纯数字字符串，转为数字比较
    否则就按照字符串比较
### 逻辑运算符
    逻辑运算符都是针对“布尔值”进行的运算，如果不是布尔值也会自动转换为布尔值
    基本运算规则（真值表）：
        逻辑与规则：
            true  &&  true  === true
            true  &&  false === false
            false &&  true  === false
            false &&  false === false
        逻辑或规则：
            true  ||  true  === true
            true  ||  false === true
            false ||  true  === true
            false ||  false === false
        逻辑非规则：
            !true  ===  false
            !false ===  true
    逻辑运算符的“短路现象”
        如果一个判断语句中，通过逻辑运算需要进行多项判断，而且不同的判断具有不同的复杂程度，则应该将简单的判断放在前面，就可以利用“短路”现象提高效率
### 连接、赋值、条件运算符
    字符串运算符：
        符号只有一个：“.”，衍生为“.=”;
        含义：就是将两边的字符串连接起来
        如果两边不是字符串，就会自动转换为字符串，然后连接起来
    赋值运算符：
        一个基本赋值运算符：“=”
        衍生：
            +=
            -=
            *=
            /=
            %=
    条件（三目、三元）运算符：
        只有一个，形式：
            数据值1 ? 数据值2 : 数据值3
        含义：
            对数据值1进行逻辑判断，如果为“真”，则该运算符的运算结果是数据值2，否则就是数据值3
### 位运算符基础
    基础规定：
        位是什么？就是2进制数字的每一个“位”，一个整数数字，有（由）32个位构成
        位运算符是仅仅针对整数进行的运算符
        位运算符有：
            &：按位与
            |：按位或
            ~：按位非、按位取反
            ^：按位异或
        位运算符的基本语法规则：
            按位与基本规则：
                1 & 1 === 1
                1 & 0 === 0
                0 & 1 === 0
                0 & 0 === 0
            按位或基本规则：
                1 | 1 === 1
                1 | 0 === 1
                0 | 1 === 1
                0 | 0 === 0
            按位非基本规则：
                ~1 === 0
                ~0 === 1
            按位异或基本规则：
                1 ^ 1 === 0
                1 ^ 0 === 1
                0 ^ 1 === 1
                0 ^ 0 === 0
### 按位与运算
    整数的按位与运算（&）：
        形式：
            $n1 & $n2; // n1，n2是两个整数
        含义：
            将该两个整数的2进制数字形式的每一个对应位上的数字进行基本按位与运算之后的结果
### 按位或运算、按位左移运算
    整数的按位或运算（|）：
        形式：
            $n1 & $n2; // n1，n2是两个整数
        含义：
            将该两个整数的2进制数字形式的每一个对应位上的数字进行基本按位与运算之后的结果
    整数的按位左移运算：
        含义：
            $n1 << $m
        形式：
            将数字n1的二进制数字形式（32位）的每一个位上的数字都一次性往左边移动m位，并将右边空出的位置补0，左边多出的不管，这样操作之后的结果
### 原码、反码、补码介绍
    原码：
        就是一个二进制数字，从“数学观念”上来表达出的形式，其中规定：
            一个数字的最左边一位是“符号位”，0表示正数，1表示负数
    反码：
        正数的反码就是其本身，不变
        负数的反码是符号位不变，其余位取反
    补码：
        正数的补码就是其本身，不变
        负数的补码是符号位不变，其余位取反后+1
        
    5：
        原码：00000000 00000000 00000000 00000101
        反码：00000000 00000000 00000000 00000101
        补码：00000000 00000000 00000000 00000101
    -3：
        原码：10000000 00000000 00000000 00000011
        反码：11111111 11111111 11111111 11111100
        补码：11111111 11111111 11111111 11111101
    
    计算机内部的运算实际全都是使用补码进行的，而且运算的时候，符号位不再区分，直接也当作数字参与运算：
    5+3：
        00000000 00000000 00000000 00000101 + 00000000 00000000 00000000 00000011 = 00000000 00000000 00000000 00001000 // 2的3次方为8
    5-3:
        00000000 00000000 00000000 00000101 + 11111111 11111111 11111111 11111101 = 00000000 00000000 00000000 00000010 // 2的1次方为2
### 管理一组开关状态1
    什么是开关状态？
        现实中，有很多数据都是只有2种结果，对应的就是布尔类型
    这里所谓管理一组事物的开关状态，应该理解为其实就是管理若干个只有2个状态的“数据符号”
        比如，有5个灯泡，对应5个状态数据
        这5个灯泡，就有2⁵种状态
    这里的管理目标是使用一个变量，就可以表达若干个数据的“当前状态”
### 管理一组开关状态2
    看视频
### 数组运算符、错误控制运算符、运算符的优先级
    数组运算符：
        +：将右边的数组项合并到左边的数组后面，得到一个新数组，如果有重复键，则结果以左边为主
        ==：如果两个数组具有相同的键和值，可以顺序不同，类型不同，返回true
        !=：
        ===
        !==
    错误控制运算符：
        @：通常用在连接数据库语句上，在语句前加上@符号，如果连接数据库失败，就屏蔽失败的错误提示
    运算符的优先级：
        要意识到运算符有优先级
        括号最优先，赋值最落后
        先乘除后加减
        大致：单目运算符 > 算术运算符 > 比较运算符 > 逻辑运算符（除了“非”运算）
### 流程控制之流程图
    看视频
### 分支结构
    if分支结构：
        if (条件判断1) {
            分支1;
        } else if (条件判断2) {
            分支2;
        } else {
            else分支
        }
    switch分支结构：
        switch (表达式) {
            case 值1：
                分支1;
                break; // 可以省略
            case 值2：
                分支2;
            ......
            default:
                default 分支;
        }
### for循环结构
    for循环结构：
        for($i = 1; $i <= 9; ++$i) {
            代码块
        }
##  05
    学习第五天的知识
### day4复习
    看视频
### day4作业（星星图案）
    看视频
### day4作业（百钱百鸡）
    看视频
### 循环的中断
    break:用于完全终止某个循环，让执行流程进入到循环语句后面的语句
        break n：中断第n层的循环
    continue：用于停止正在进行的当前循环，直接进入下一次循环
        continue n：跳过第n层的当前循环，进入第n层的下一次循环
### do while循环，循环3要素
    看视频
### 控制脚本运行进度
    看视频
### 文件加载初步，路径问题
    文件加载：
        综述和基本语法：
            有4个文件加载语句：
                include
                require
                include_once
                require_once
            他们的使用形式完全一样
            潭门的含义几乎完全一样，只有在加载失败时或是否重复加载这种情况有所不同
        文件加载的路径问题：
            有三种路径形式可以使用：
                相对路径：
                    是相对于当前网页文件所在的位置来定位某个被加载的文件位置
                绝对路径：
                    本地绝对路径：从系统磁盘开始
                    网络绝对路径：从网站根目录开始
                无路径：只给出文件名
### 文件载入详细过程
    文件载入和执行过程详解：
        从include语句处退出php脚本模式（进入html代码模式）
        载入include语句所设定的文件中的代码，并执行之
        退出html模式重新进入php模式，继续执行之后的代码  
### 四个载入语句的区别
    include和require的区别：
        include载入文件失败时（即没有找到该文件），报一个“提示错误”，然后继续执行后续代码
        require载入文件失败时，报一个“致命错误”，终止代码
    include和include_once的区别：
        include载入的文件不判断是否载入过，include_once只载入一次
### 被载入文件的返回值及return的作用
    看视频
### 错误分类
    通常分三种：
        语法错误：程序运行之前，都要先检查语法，如果语法有错，会立即报错并终止执行
        运行时错误：就是在程序语法检查通过后，开始运行程序并在此过程中遇到的错误
            提示性错误：
            警告性错误：
            致命错误：
        逻辑错误：指的是程序本身可以正常执行，没有报错，但“计算结果”错了
### 错误分级
    php语言中，将各种错误进行了不同级别的分类归纳，并形成大约有十几个级别的错误，这就是技术层面的错误分级
    每一级别的错误都有一个系统常量：
        系统常见错误：
            E_ERROR：致命错误
            E_WARNING：警告性错误
            E_NOTICE：提示性错误
        用户可自定义的错误：
            E_USER_ERROR：自定义致命错误
            E_USER_WARNING：自定义警告性错误
            E_USER_NOTICE：自定义提示性错误
        其它：
            E_STRICT：严谨性语法检查错误
            E_ALL：代表所有错误
### 错误触发
    有两种方式触发错误：
        系统触发：程序运行到某处代码出现了某种错误，此时系统就会报错
            E_ERROR：致命错误：导致程序无法执行后续语句
                比如调用一个不存在的函数
            E_WARNING：警告性错误：会输出错误提示，并继续执行后续代码（也可能看具体情况）
            E_NOTICE：提示性错误：会输出错误提示，并继续执行后续代码
                比如使用不存在的常量或变量
        自定义触发：
### 是否显示错误报告
    错误报告的显示问题：
        是否显示错误报告：
            php.ini中，设定display_errors的值，on，off
            直接在php中通过ini_set('display_errors', '0')设置
        显示哪些级别的错误报告
### 显示哪些级别的错误
    看视频
### 错误日志记录问题
    是否记录：
        在php.ini中，设置log_error = on 或 off
        在php中，通过ini_set('log_error', '0')设置
    记录到哪里：
### 自定义错误处理器
    看视频
##  06
### day5复习
    看视频
### day5作业
    看视频
### 函数初步，函数参数问题
    函数基础：
        函数的定义：
            形式：
                function 函数名 (形参1,形参2,......) {
                    函数体
                }
            说明：
                定义对使用的形参，其实就是一个变量，只能在函数内部使用的变量
                形参作为变量
        函数的调用：
            形式：
                函数名 (实参1,实参2,......)
            说明：
                实参应该要与调用的函数的形参一一对应
                实参就是形参的值
        函数调用的详细过程：
            寿险将函数调用时的实参数据，传递（赋值）给函数的形参
            程序的执行流程，进入函数内部运行函数体代码
            在函数内部，按正藏的流程顺序，执行其中的代码
            直到函数结束，则退出该函数内部，返回到调用函数的位置往下执行代码
            如果在函数内部执行的过程中，有return语句，则会立即终止函数内部的执行，并返回数据到函数调用位置
        函数的参数问题：
            函数形参的默认值问题：
                可以给一个函数定义时的形参赋值一个“默认值”，则这个函数被调用时，对应的实参可以不传
            形参的传值问题：
                值传递：
                引用传递：
### 函数参数的数量问题
    通常，函数调用时的实参数量应该与被调用的函数定义的形参数量一直
    如果函数定义时，形参有默认值，则调用该函数传递的实参数量可以省略有默认值的形参
        注意，省略只能有后往前
    有一种定义函数的特别形式（并不常见），它不定义形参，而实参任意给出
### 函数的返回值问题
    函数的返回值不受语法规定，根据需求，需要返回就return，不需要就不return
### 可变函数及应用
    可变变量：
```php
        $v1 = 'abc';
        $abc = 123;
        echo $$v1;
```
    可变函数：
```php
        function f1() {
            echo '<br/>';
        }
        $v1 = 'f1';
        $v1();       
```
        这就是可变函数
        可变函数其实就是在调用函数的时候，使用一个变量名
        该变量的值就是函数名
### 有关可变函数和函数的概念复习
    看视频
### 匿名函数
    匿名函数就是没有函数名的函数
    有两种形式：
        将一个匿名函数赋值给一个变量，此时该变量就代表该匿名函数
        直接将一个匿名函数当作实参来使用，即调用其它函数的时候，使用一个匿名函数当作实参，在被调用的函数内部使用该匿名函数
### 匿名函数再解释
    看视频
### 不同的作用域和对应的不同变量
    变量的作用域：
        一个变量，在什么范围中可以使用的情况
    php中，有三种变量作用域：
        局部作用域：就是指一个函数内部的范围
        全局作用域：在函数外部定义的不能被函数内部使用，可以被函数外部的代码使用
        超全局作用域：就是指所有的代码范围
### 局部使用全局变量做法1
    在函数内部使用函数外部的全局变量，需要在变量名前加上global关键字，声明变量是全局变量
```php
        $v1 = 4;
        function v1() {
            global $v1;
            echo $v1;
            $v1 = 44;
        }
        echo $v1; 
```
### 局部使用全局变量做法2
    使用$GLOBALS超全局变量
### 函数的一般知识
    有关函数的系统函数：
        function_exists(函数名)：判断一个函数是否被定义过
        func_get_arg()：
        func_get_args()：
        func_num_args()：
    其它系统函数：
        字符串函数：
        时间函数：
        数字函数：
### 递归思想
    递归思想——递归函数
    在一个函数内部调用函数本身，并且可以控制的就是递归
    当面对一个“大问题”，该大问题可以经由该问题的同逻辑问题的“小一级”问题而经过简单计算获得，而且可以获知这类问题的最小一级的答案
### 递归再演示和总结
    看视频
### 递推思想演示
    递推（迭代）思想
    一般以循环的形式实现
    如果要求一个“大问题”，且该问题有如下两个特点：
        已知该问题的同类问题的最小问题的答案
        如果知道这种问题的小一级问题的答案，就可以轻松求得其“大一级”问题得答案，并且此问题得级次有一定的规律
##  07
### day06复习
    看视频
### day06作业
    看视频
### 数组初步
    数组：
        数组基础：
            数组定义（赋值）：
                $arr = array(1, 2, 3, 4, 5); // 这是最常见的数组（枚举、索引数组），下标为默认下标，从0开始的数组
                $arr = array('a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5); // 这是关联数组，下标为字符串，人为定义
                下标可以人为定义
                下标可以由数字和字符串混合
                没有给出下标的数据项会以前面数据项中最大的数字下标加一为下标
                小数小标会自动向下取整
                下标如果有重复，后面的数据项会覆盖前面的数据项
            数组取值：
        数组的分类：
            按键值关系来分：
                索引（枚举）数组：数组下标严格从0开始
                关联数组：数组下标都是“字符串”且命名上具有含义
                混合数组：既有数字下标，也有字符串下标
            按数组的维数（复杂程度）来分：
                一维数组：
                    $arr = array();
                二维数组：
                    $arr = array(
                        array();
                    );
                多维数组：
### 数组常见使用
    看视频
### 有关数组交换的补充解释
    看视频
### 数组的基本遍历和指针操作
    数组的遍历：
        foreach基本语法：
            foreach (数组 as [$key =>] $value) {
                // []内可以省略
                // 循环体代码
                // $key是每个单元项的下标
                // $value是每个单元项的值
            }
    数组的指针操作及遍历原理：
        正常情况下数组的指针从第一项单元开始
        数组作为一个“总体数据单位”，有如下指针操作函数：
            current(数组)：获取数组当前指针所在单元的值
            key(数组)：获取数组当前指针所在的键
            next(数组)：将数组的指针移向下一个单元并返回所在单元的值
            prev(数组)：将数组的指针移向上一个单元并返回所在单元的值
            end(数组)：将数组的指针移向最后一个单元并返回所在单元的值
            reset(数组)：将数组的指针移向第一个单元并返回所在单元的值
### 数组遍历原理图
    看视频
### for、next遍历数组
    看视频
### each()函数的作用
    each()函数的作用，先取得数组当前单元的键值并放入一个新数组，然后将指针移向下一个单位
    新数组中有四个单元，键分别是0、1、key、value，0和key的值是each取得的键值中的键，1和value的值是each取得的键值中的值
### while、each、list遍历
    list()函数的使用：
        list(变量1,变量2,......) = 数组
        根据list中的变量数量，取得枚举数组中从第一个单元开始往后相同数量的值，并于变量一一对应，变量数量不能超过数组
### foreach遍历细节探讨
    foreach是正常的循环语法结构，可以有break和continue等操作
    遍历过程中值变量默认的传值方式是值传递
    遍历过程中值变量可以人为设定为引用传递
    foreach默认是原数组上进行遍历，但如果在遍历过程中对数组进行了某种修改和某种指针性操作，则会复制数组后在复制的数组上继续遍历循环
    在foreach中如果值变量是引用传递，则无论如何都是在原数组上进行
### 数组排序函数的应用
    看视频
### 冒泡排序
    看视频
### 选择排序
    看视频
##  08
### day7复习
    看视频
### day7作业
    看视频
### 二分查找
    看视频
### MySQL介绍
    数据库是什么：
        数据库分类：
            层次数据库
            网状数据库
            关系数据库
        主流数据库：MySQL、SQL Server、Oracle
        SQL：这是关系数据库的“语言标准”，struct query language（结构化查询语言）
    数据存储的本质和表现：
        数据库系统 （一对多） 数据库
        数据库 （一对多） 数据表
        数据表 （一对多） 数据行（记录）
        数据行（记录） （一对多） 数据项（字段）
    基本概念：
        数据（data）
        数据库（database）：用于存储一个项目相关的各种数据的一个逻辑单位
        数据库管理系统（DBMS）：数据库系统的软件产品
        数据表（table）：用于存储数据的文件
        字段（field），列（column）：一个数据表中一个纵列的名字
        行（row），记录（record）
### 数据库系统基本操作
    启动/停止mysql数据库服务：
        命令行模式：
            启动：net start mysql
            停止：net stop mysql
        服务模式：
            控制面板 -> 管理工具 -> 服务 -> mysql -> 启动服务
    登录/退出mysql系统
        登录：
            mysql -h 服务器地址 -u 登录名 [-p 端口号] -p
            mysql --host=服务器地址 --user=用户名 --port==端口号 --password
        退出：
            quit;
            exit;
    注意：登录数据库系统后，需要使用“set names 编码名;”来设定当前连接数据库系统的“环境编码名”
    数据库的备份与恢复
        备份：就是将一个数据库，完整地转换为一个可以随时携带和复制的文件
            mysqldump -h 服务器地址 -u 登录名 -p 数据库名 > 文件名
        恢复：将一个备份的文件完整地还原为数据库
            mysql -h 服务器地址 -u 登录名 -p 数据库名 < 文件名
        注意：
            这两个命令，都是在没有登录进入数据库的时候使用
            其中备份命令还要求为管理员身份
### 基本语法规定
    注释：
        单行注释：#注释内容
        单行注释：-- 注释内容
        多行注释：/* 注释内容 */
    语句行：
        默认情况下，以一个英文分号作为一条语句的结束
    大小写问题：
        mysql语言内部本身不区分大小写，但mysql的某些命令执行文件（夹），此时可能会区分大小写：
            在区分文件（夹）名称大小写的系统中，这些名字也会区分大小写，比如unix，linux系统
            在文件（夹）名称不区分大小写的系统中，这些命令也不区分，比如windows
    命名问题：
        可以自己命名的名字。称为标识符，包括：数据库名、表名、字段名、视图名、函数名、过程名、变量名、用户名
        可以命名标识符的字符比常规的语言多，但建议只用字母数字和下划线且不用数字开头
        非常规字符或系统关键字虽然可以作为标识符使用，但最好包在反引号中
        对数据库名，表名和视图名，在window系统中不区分大小写，而其他系统中区分，建议全使用小写
        对其它自己命名的标识符，不区分大小写，但建议小写，并使用下划线分割法
### 创建数据库及有关编码问题
    数据库定义语句：
        创建数据库：
            create database 数据库名 [charset 字符编码名称] [collate 排序规则]
                字符编码名称是用于设定当前数据库中存储的字符内容的编码格式
                collate排序规则用于设定其中的字符内容的“大小/先后”关系
### 数据库的其它操作
    删除数据库：
        drop database [if exists] 数据库
        删除数据库，[如果数据库不存在，也不会报错]
    现实所有数据库：
        show database
    显示一个数据库的创建语句
        show create database 数据库名
    进入数据库
        use 数据库名
### 数据类型总览
    字段类型（数据类型）
        总览：mysql中，数据类型主要分三大类：数字型，字符型，时间型
### 整数
    整数类型：
        int：占4个字节，即32位
        tinyint：占1个字节，即8位，最多存储256个数字，默认范围是-128~127
        smallint：
        bigint：占8个字节，即64位
    整数类型字段的设定形式：
        类型名 [M] [unsigned] [zerofill]
        M表示设定该整数的显示长度，即select输出的时候，123可能显示为000123，假设M为6
        unsigned用于设定该整数为“无符号数”，其实就是没有负数
        zerofill用于设定是否填充“0”到一个数字的左边，此时，需要与设定的长度M配合使用
### 小数类型
    float：单精度浮点型，使用4个字节存储数据，其精度大约只有6-7个有效数字数位
    double：双精度浮点型，使用8个字节存储数据，其精度大约20个有效数字数位
    decimal：定点小鼠类型，整数部分最长可以存65位，小数部分最长可以存储30位，一般设置格式为decimal(整数部分位数,小数部分位数)
### php操作数据库的知识点复习
    $link = mysql_connect('数据库服务器地址', '用户名', '密码'); // 连接数据库
    mysql_query('set names 网页文件编码名'); // 设定连接编码 mysql_set_charset('网页文件编码名')
    mysql_query('use 数据库名'); // 选定要使用的数据库 mysql_select_db('数据库名')
### php操作数据库的扩展知识
    看视频
##  09
### day8复习
    看视频
### day8作业
    看视频
### phpmyadmin的配置
    看视频
### varchar、char类型
    字段类型：
        字符类型：
            varchar：可变长度字符串，使用时必须设定其长度，理论最大长度65535，实际最大长度65533，但根据存储的字符编码不同，也会有进一步减少，如中文gbk编码，最多56633/2个，若utf8，则最多65533/3
            char：定长字符串，使用时通常需要设定存储长度，如果不设定，默认是1，最大长度255个，定长字符串适用于存储的数据都是可预见的明确的固定长度的字符，比如手机号，中国邮政编码，实际存储的时候，如果少于设定长度，也能存，但都会补空格填满
### enum、set类型
    字符类型：
        enum：单选项字符串数据类型，非常适合于存储表单界面中的“单选项值”，设定的时候，需要给定“固定的几个选项”，然后存储的时候，就只存储其中一个值，如enum("选项1", "选项2", "选项3", ...)，实际内部这些字符串选项对应的是如下数字值1、2、3，最多可以有65535个选项
        set：多选项字符串数据类型，非常适合于存储表单界面中的“多选项值”，设定的时候，需要给定“固定的几个选项”，然后存储的时候，可以存储若干个值，这些字符串选项值对应的是1、2、4、8....，最多64个选项
        text：长文本字符类型，存储的数据不占据表格中的数据限制，最长可存储65535个字符，其它同类型字符类型：smalltext、tinytext、longtext
        其它：
            binary：定长二进制字符串类型，存储的是二进制值
            varbinary：变长二进制字符串类型，存值的是二进制值
            blob类型：二进制数据类型，存的仍然是二进制值，但其适用于存储图片等文件
### 时间日期类型
    常用的时间类型：
        datetime：时间日期类型
        date：日期类型
        time：时间类型
        year：年份类型
        timestamp：时间戳类型，就是指一个时间的“UNIX数据值”，本质是一串数字，重要作用是会自动获取当前的时间戳
### 表创建语句形式及属性形式
    表定义语句：
        创建表：
            基本语法形式：
                create table [if not exists] 表名 (字段列表 [, 索引或约束列表])[表选项列表]
            字段设定形式：
                字段名 类型 [字段属性列表]
                    字段名可以自己取
                    类型就是数据库数据类型
                    字段属性根据具体的需要可以有多个，相互之间空格隔开：
                        auto_increment：只用于整数类型，让该字段的值自动获得一个增长值
                        primary key：用于设定该字段位为主键，该字段的值唯一确定
                        not null：该字段不能为空
                        default xxx值：用于设定该字段的默认值
                        comment：字段说明文字
                        unique key：设定该字段中的值唯一
### 索引基本概念及用法
    什么是索引？
        索引是系统内部自动维护的隐藏的“数据表”，可以极大地加快数据的查找速度！
        这个隐藏的速度表，其中的数据是自动排好序的，其查找速度建立在这这个基础上
    建立索引
        指定一个表的某些字段作为“索引数据字段”
        索引类型(字段名)：
            key：普通索引类型，就是一个索引而已，没有其它作用，只能加快查找速度
            unique key：唯一索引类型，可以设定其字段内的值唯一，不能重复，可以为空
            primary key：主键索引类型，具有区分该表中的任何一行数据的作用（记录唯一性），不能为空
            fulltext：全文索引类型
            foreign key：外键索引类型，foreign key (字段名) references 其他表中的字段名
### 外键索引
    看视频
```
        CREATE TABLE IF NOT EXISTS banji(
        	id INT AUTO_INCREMENT,
        	banjihao VARCHAR(10) COMMENT '班级号',
        	banzhuren VARCHAR(10) NOT NULL COMMENT '班主任',
        	open_date DATE COMMENT '开班日期',
        	PRIMARY KEY(id),
        	UNIQUE KEY(banjihao)
        ) ENGINE=InnoDB;
        
        CREATE TABLE IF NOT EXISTS xuesheng(
        	id INT AUTO_INCREMENT,
        	name VARCHAR(10) COMMENT '姓名',
        	age TINYINT,
        	banji_id INT COMMENT '班级id',
        	PRIMARY KEY(id),
        	FOREIGN KEY(banji_id) REFERENCES banji(id)
        ) ENGINE=InnoDB;
```
### 百万计数据的索引演示
    看视频
### 约束
    什么叫约束？
        约束就是要求数据需要满足什么条件的一种规定
    约束的种类：
        主键约束：primary key(字段名)
            含义：使该设定字段的值可以用于“唯一确定一行数据”，其实就是主键的意思
        唯一约束：unique key(字段名)
            含义：使该设定字段的值具有“唯一性”
        外键约束：foreign key(字段名) references 其它表名(字段名)
            含义：使该设定字段的值，必须在其设定的对应表中的对应字段已经有该值了
        非空约束：not null，其实就是设定一个字段不能为空
        默认约束：default '默认值'，设定一个字段为空时的默认值
        检查约束：check (判断语句)，设定字段的值必须符合判断语句的要求
### 表选项
    表选项就是创建一个表的时候，对该表的整体设定，主要有如下几个：
        charset：要使用的字符编码
        engine：要使用的存储引擎（也叫表类型），设定的字符编码是为了跟数据库设定的不一样，如果一样，就不需要设定了，因为其会自动使用数据库级别的设定
        auto_increment：设定当前表的自增长字段的初始值，默认是1
        comment：该表的一些文字说明
### 修改表
    创建表能做的事，修改表几乎都能做
    不推荐修改表，在创建表的时候应该确定好表的结构
        可以对字段进行添加、删除、修改
        可以对索引进行添加、删除
    常见操作：
        添加字段：alter table 表名 add [column] 新字段名 字段类型 [字段属性列表]
        修改字段：alter table 表名 change [column] 旧字段名 新字段名 新字段类型 [新字段属性列表]
        删除字段：alter table 表名 drop [column] 字段名
        添加普通索引 alter table 表名 add key [索引名] (字段名1[, 字段名2, 字段名3, ......])
        添加唯一索引：alter table 表名 add unique key [索引名] (字段名1[, 字段名2, 字段名3, ......])
        添加主键索引：alter table 表名 add primary key [索引名] (字段名1[, 字段名2, 字段名3, ......])
        修改表名：alter table 旧表名 rename [to] 新表名
### 表的删除及其它相关语法
    显示当前数据库中的所有表：show tables
    显示某表的结构：desc 表名 / describe 表名
    显示某表的创建语句：show create table 表名
    重命名表：rename table 旧表名 to 新表名
    从已有表复制表结构：create table [if not exists] 新表名 like 被复制表名
### 视图
    什么叫视图？
        就是被封装起来的SQL语句的代码 —— 函数。
    视图的创建语句：
        create view 视图名 as select语句
        create view v1 as select id, f1, name, from 表1 where id > 7 and id < 100 and or f1 < 10000 and age > 10;
    使用视图：
        基本上当作一个表用
        select * from v1;
    删除视图：
        drop view [if exists] 视图名
##  10
### day09复习
    看视频
### day09作业
    看视频
### 数据库设计三范式
    第一范式（1NF）：
        原子性：使数据不可再分
    第二范式（2NF）：
        唯一性：使每一行数据具有唯一性，并清除数据之间的“部分依赖”（只要给表设定主键，就可以保证唯一性）
            依赖：就是在一个表中，其中某个字段B的值可以由另一个字段A的值来决定，此时字段B依赖于字段A，一般来说主键决定其它字段，其它字段依赖于主键
            部分依赖：如果某个字段只依赖于“部分主键”，就是部分依赖（这种情况是因为表中有多个主键）
            完全依赖：某个字段依赖于“主键的所有字段”（如果一个表只有一个主键字段，则必然是完全依赖）
    第三范式（3NF）：
        独立性：消除传递依赖，使每个字段都独立于依赖主键字段，要消除其中部分非主键字段的内部依赖（将部分依赖的几个字段单独建一个表）
            传递依赖：某些字段除了依赖于主键字段，还会依赖于其它某些字段
### 插入语句语法
    插入数据（增）：
        多种语法形式：
            insert [into] 表名[(字段名1, 字段名2, 字段名3, ......)] values(值表达式1, 值表达式2, 值表达式3, ...),(......),.....
                这是最常用的插入语句，可以一次性插入多行数据，用逗号隔开
                插入语句，可以理解为每次插入数据都是以“行”为单位插入
                字段名通常不推荐省略，其后续的“值列表”应该跟字段名列表“一一对应”
                其中的值表达式，可以是一个“直接的”，或“函数调用结果”，或变量值，其中如果对应字段使字符或者时间类型，则直接值应该使用单引号
            replace [into] 表名[(字段名1, 字段名2, 字段名3, ......)] values(值表达式1, 值表达式2, 值表达式3, ...),(......),.....
                与形式1几乎一样，唯一区别是如果插入的数据的主键或唯一键“有重复”，则此时就会变成“修改该行数据”
            insert [into] 表名[(字段名1, 字段名2, 字段名3, ......)] select 字段名1, 字段名2, 字段名3, ...... from 其它表名
                将select语句查询结果的数据（可能多条）都插入到指定的表中
                其中也需要字段的对应
            insert [into] 表名 set 字段名1 = 值表达式1, 字段名2 = 值表达式2, 字段名3 = 值表达式3, ......
### load data载入数据语句
    看视频
### 数据删除和修改
    删除数据（删）：
        语法形式：
            delete from 表名 [where 条件] [order by 排序] [limit 限定]
        说明：
            删除数据仍然是以“行”为单位进行
            通常删除数据都需要带where条件，否则删除所有数据
            where条件的语法跟select中的语法一样
            order by排序设定，用于指定这些数据的删除顺序，它通常跟limit配合使用才有意义
            limit限定用于设定删除多少行
            实际应用中，通常很少用到order by和limit
    修改语句（改）：
        语法形式：
            update 表名 set 字段1 = 值1, 字段2 = 值2, 字段3 = 值3, ......[where 条件] [order by 排序字段] [limit 限定行数]
        说明：
             通常，update语句也都需要where条件语句，否则就会修改所有数据
             where条件的语法跟select中的语法一样
             order by排序设定，用于设定修改的顺序，limit用于设定修改的行出，他们通常结合使用
             注意，其中的数据值，如果是字符串和时间类型的直接值，就应该使用单引号
### 字段或表达式，all和distinct
    基本查询：
        基本语法形式：
            select [all | distinct] 字段或表达式列表 [form 子句] [where 子句] [group by 子句] [having 子句] [order by 子句] [limit 子句]
        字段或表达式列表：
            字段，自然是来源于“表”，必然依赖于from子句
            表达式是类似于这样一个内容：8、8+3、now()
        all和distinct：
            用于谁当select出来的数据是否消除“重复行”
                all：不消除，所有都取出来
                distinct：消除
### from子句
    看视频
### where子句
    看视频
### is运算符
    空值和布尔值的判断
    四种情况：
        is null：判断某个字段是null
        is not null：判断某个字段不是null
        is true:判断某个字段为真
        is false:判断某个字段为假
### between和in运算符
    between运算符：范围判断
        用于判断某个字段的数据是否在某个特定的范围之间
        between 值1 and 值2
        字段的值给定在值1和值2之间，大于等于值1，小于等于值2
    in运算符：给定确定数据列表
        in (值1, 值2, 值3, ...)
### like语法
    like运算符：对字段进行模糊查找
    like %要查找的内容%
        %：代表任何个数的任何字符
        _：代表一个任何字符
### group by分组子句（1）
    group by：分组
        group by 字段1 [desc | asc, 字段2 desc | asc, ...]
        分组是对已经找出的数据根据排序字段进行的分组
        同时该分组结果可以同时指定其排序方式desc，asc
        通常，分组就一个字段依据
    什么叫做分组？
        分组，就是将多行数据，以一定的标准来进行分类存放
### group by分组子句（2）
    看视频
### having分组子句
    having的作用跟where一样，但其只对“分组的结果数据”进行筛选
### order by排序子句
    用于将取得的数据进行排序
    order by 字段1 [desc | asc, 字段2 desc | asc, ......]
    对前面的结果数据以指定的一个或多个字段排序
    排序可以设定升序或降序，默认是升序
    多个字段的排序，都是在前一个字段排序号的基础上，前一个字段中有相等的数据按后一个字段的排序结果
### limit限定子句
    用于将取得的数据结果按指定的行数取出来，从第几行开始取几行
    limit 起始行数 截取行数
    起始行数都是从0开始算起的，起始行号跟数据中的任何一个字段（比如id）没有关系
    截取行数也是数字，大于0
    简写：limit 截取行数：起始行数默认0
### 对select查询语句的总结
    看视频
##  11
### day10复习
    看视频
### day10作业
    看视频
### day10作业 —— 表单的一个改进
    看视频
### 连接基本概念和形式
    连接查询：
        基本概念：
            将两个或两个以上的表连接起来，当作一个表
            将每一个表的每一行数据两两之间连接起来，每次对接的结果就是连接结果的一行
        语法：
            select * from 表1, 表2 
            select * from 表1 join 表2 
            select * from 表1 cross join 表2
        连接基本形式：
            在代码级别，连接的基本形式为：
                表1 [连接形式] join 表2 [on 连接条件]
            如果是3个表：
                表1 [连接形式] join 表2 [on 连接条件] [连接形式] join 表3 [on 连接条件]
### 交叉连接
    连接的分类：
        交叉连接：
            起始就是基本的连接形式，没有条件，只是将所有数据行都连接起来的结果，叫做“笛卡尔积”
            对于表1（n1个字段，n2行），表2（m1个字段，m2行），它们交叉的结果是有n1*m1个列，n2*m2个行
### 内连接
     内连接：
        形式：select * from 表1 inner join 表2 on 连接条件
### 左连接、右连接、全连接
    左（外）连接：
        其实就是将两个表的内连接的结果，在“加上”左边表的不符合内连接所设定的条件的那些数据的结果
        表1（左表） left [outer] join 表2（右表） on 连接条件
    右（外）连接：
        其实就是将两个表的内连接的结果，在“加上”右边表的不符合内连接所设定的条件的那些数据的结果
        表1（左表） right [outer] join 表2（右表） on 连接条件
    全（外）连接：
        mysql不支持全连接的语法
        其实就是将两个表的内连接的结果，在“加上”左边表的不符合内连接所设定的条件的那些数据的结果以及左右边表的不符合内连接所设定的条件的那些数据的结果
        表1（左表） full [outer] join 表2（右表） on 连接条件
### 连接查询举例
    看视频
### 子查询基本概念
    基本含义：
        一个select语句就是一个查询语句：select 字段或表达式 from 数据源 where 条件判断语句
        上述select部分，from部分，where部分往往都是一些数据或数据的组合
        from部分当然就是表或表的连接结果，他们也是数据，只是通常为表数据
        所谓子查询，就是在一个查询语句中的内部的某些位置出现的另外一条完整的查询语句，则有两个概念：主查询，子查询
    在形式上：
        select 字段或表达式或子查询 [as 别名] from 表名或连接结果或子查询 where 字段或表达式或子查询的条件判断语句
### 子查询分类
    按子查询结果分为：
        表子查询：
            子查询的结果是一个多行多列的数据表
        行子查询：
            子查询的结果是一行多列的数据，通常放在“行比较语法”中：where row(字段1, 字段2) = (select 行子查询)
        列子查询：
            子查询的结果是多列一行的数据
        标量子查询：
            一个子查询返回的结果理论上是一行一列的时候，此时可以当作一个单个值使用
    按子查询位置分为：
        作为主查询的结果数据：
            select c1, (select f1 from tab2) as fl1 from tab1
        作为主查询的条件数据：
            select c1 from tab1 where c1 in (select f1 from tab2)
        作为主查询的来源数据：
            select c1 from (select f1 as c1, f2 from tab2) as t2
### 常用子查询
    比较运算符中的子查询：
        形式：
            操作数 比较运算符 (标量子查询)
        说明：
            操作数，其实就是比较运算符的2个数据之一而已，通常就是一个字段名
        举例：
            找出价格最高的所有商品：select * from product where price = (select max(price) from product)
    使用in的子查询：
        形式：
            操作数 in (列子查询)
        举例：
            找出所有类别名字中带“电”的所有商品：select * from product where id in(select id from product where name like '%电%')
    使用any的子查询：
        形式：
            操作数 比较运算符 any (列子查询)
        含义：
            当某个操作数对于该列子查询的其中任一个值，都满足该比较运算符，就算是满足了条件
        举例：
            表1中的id只要大于表2中的f1列中任意一个值：select * from tab1 where id > any (select f1 from tab2);
    使用all的子查询：
        形式：
            操作数 比较运算符 all (列子查询)
        含义：
            当某个操作数对于该列子查询的所有数据值全部都满足，就算是满足了条件
        举例：
            表1中的id必须大于表2中的id列中所有的值：select * from tab2 where f1 > all (select id from tab1)
    使用some的子查询：
        是any的同义词
### exists子查询
    使用exists子查询：
        形式：
            where exists(子查询)
        含义：
            该子查询如果有数据，则exists的结果是true，否则是false
        举例：
            select * from where exists (select * from ta1);
        说明：
            因为，exists子查询的含义造成主查询往往出现要么全部出来数据要么都不取出，实际应用中，往往都不是独立的子查询，而是会需要跟主查询的数据源建立连接关系
### 联合查询
    union：
        基本概念：
            将两个具有相同字段数量的查询语句的结果，以上下堆叠的方式合并为一个查询结果，两个select语句的查询结果的字段数必须一致，通常也应该让两个查询语句的字段类型基本一致
        语法形式：
            select语句1 union [all | distinct] select语句2 union ......
        说明：
            联合查询语句默认会自动消除重复行数据，即distinct
    看视频
##  12
### day11复习
### day11作业
### 用户管理
### 权限管理
### 事务的基本概念和特点
### 事务模式
### 事务执行流程
### 语句块包含符
### 流程控制
### 变量
### 函数
### 存储过程
### php中使用存储过程和存储函数
### 触发器
### 三表查询作业
##  13