#   01
    开始第一天的学习
##  php介绍、php脚本模式
    php：Personal Home Page => HypeText Preprocessor
    历史：
        1995PHP/FI,Rasmus LorderfmPersonal Home Page
        1997PHP/FI2.0
        1998PHP3
        2000PHP4
        2005PHP5
    应用领域：
        web服务器端脚本（主要领域）
        命令行脚本
            运行php文件：php.exe -f "php文件路径"
            运行php文件：php.exe -f "php脚本代码"
        应用程序图形界面
##  web服务器运行模式及相关技术（软件）
    Web软件的运行模式中，总是现在客户端（浏览器），发起一个“请求”，然后，服务器端才产生反馈动作（运行程序），并因此而返回给该浏览器一定的信息（响应）
##  php网页运行原理
    TODO
##  apache的安装
    TODO
##  配置apache以运行php代码
    TODO
##  php配置 —— 时区配置
    TODO
##  php配置 —— 模块配置
    php.ini是apache的众多模块之一
    mysql.ini是php的众多模块之一
##  MySQL的安装与配置
    TODO
##  单站点配置
    TODO
##  目录访问权限（包括分布式权限）
    一个站点就是一个目录
    每个目录，都应该给其设定“访问权限”，语法如下
    <Directory "要设置权限的目录路径">
        #    设置当一个请求中没有给定请求的文件名又没有默认网页（首页）的时候，显示文件列表
        Options Indexes
        
        #    设置权限控制的先后顺序，只有两种：
                Deny,Allow（先拒绝，后允许）
                Allow,Deny（先允许，后拒绝）
        Order Deny,Allow
        
        #    Deny用于设定拒绝访问的来源地址或服务器名，几乎没有实际意义
        Deny from 拒绝名单 
            比如：deny from 192.168.3.8
        Allow from 允许名单
        
        #    设置该文件夹下的“默认网页”（首页），可以设置多个，用于请求中不带文件名的时候用该文件作为响应页面
        DirectoryIndex index.php index.html main.php
    </Directory>
    
    对于某个目录的访问权限，我们在apache中使用Directory来设定，但可能不够方便：
        apache配置修改后，必须重启apache
        某个站点中的“下级目录”访问权限，不方便单独设置
    这种，可以成为“集中式权限”：
    分布式权限：就是针对某个网站的任何一个下级目录，都可以单独去设置其访问权限，并且可以不重启apache就生效：
    # AllowOverride表示当前目录，允许“分布式”权限配置
    AllowOverride all
    #    在该目录下的任何子目录中，创建一个特殊的文件（.htaccess），在该文件中写所需要的“权限内容”（几乎与Directory的写法一样）
    Deny from all
    Allow from 192.168.3.4
##  多站点配置
    在apache的主配置文件httpd.conf中，“打开”多站点虚拟主机配置文件项（httpd-vhosts.conf）
    设定希望提供“多站点”服务的IP地址和端口号，通常默认就是：*:80，其中“*”代表所有IP在http-vhosts.conf文件中，默认其实apache安装好之后就设置好了，无需手动设置（关键字：NameVirtualHost）
    然后就一个站点一个站点加上，形式如下：
        <virtualhost *:80>
            #    设置站点1的各项信息
        </virtualhost>
    注意：
        先把httpd-vhosts.conff文件中的2个初始安装生成的站点删除
        每个站点的设置项，主要就3个：
            ServerName
            DocumentRoot
            <Directory>...</Directory>
        在多站点配置中，第一个站点被称为“默认站点”，如果某个请求的域名无法跟任何一个站点匹配，就当作默认站点
##  虚拟目录的设置
    某个站点所对应文件夹下有一个目录为d1，直接访问这个目录名则为真实目录
    该站点不存在某目录名，但可以同样访问该目录名就是虚拟目录
    
    设置目录别名的名字和其对应的“实际真实目录（文件夹位置）”
        Alias /目录别名的名字 “实际真实目录的位置”
    设置该真实目录的访问权限（否则是禁止访问的）
        <Directory “真实目录路径”>...</Directory>
#   02
    开始第二天的学习
##  day1复习
    TODO
##  day1作业
    TODO
##  php的标记形式
    PHP基本语法形式
        php的标记符：
            <?php ... ?>（推荐）
            <script language="php"> ... </script>
            <? ... ?>（不推荐，依赖于php.ini的一个设置项short_open_tag = on，需要打开）
##  php的基本语法规定
    php的结束标记：
        ?>：（纯php文件中，可以省略）
    php的区分大小写特性
        变量区分大小写
        常量通常默认也区分，但可以人为设定不区分
        其他场合的关键字都不区分
    php的注释
        单行注释：
            // 注释内容
            # 注释内容
        多行注释：
            /* 注释内容 */
##  变量的基本理解
    基本理解：
        变量可以理解为只是一个代表一定存储空间及其中数据的一个标识符
##  变量的基本操作
    基本操作：
        赋值：
            等号（=）的左边放变量名，右边放“数据”
        取值：
            任何需要一个数据的语句中使用一个变量
        判断：
            isset(变量)：判断变量是否存在或是否有数据值
        删除：
            删除一个变量，并不是指将该变量从程序中删掉，而是清除变量存储的数据
##  变量命名规则
    常见的命名法：
        驼峰命名法：
            首单词全小写，其后每个单词的首字母大写：$myName
        帕斯卡命名法：
            每个单词的首字母大写：$MyName
        下划线分割法：
            每个单词小写，并且用下划线隔开：$my_name
##  传值方式
    变量的传值方式，是指“一个变量，传给另一个变量”的内部细节形式 —— 单对单
    变量的传值方式，只有两种：
        值传递：
            $v = 1;
            $a = $v;
            将v的数据从存储空间中取出复制一份存放进a的存储空间中
        引用传递：
            $v = 1;
            $a = &$v;
            将a的存储空间地址设置为v的存储空间地址，两个变量共用一个数据
##  可变变量
    $abc = 1;
    $v = 'abc';
    $$v === $abc // true
##  预定变量综述
    预定义变量是php预先定义好的变量
    主要有：
        $_GET
        $_POST
        $_REQUEST
        $_SERVER
        $GLOBALS
    以上都是数组类型
    系统定义与维护 —— 不应赋值或销毁变量，只是拿来使用
    具有超全局作用域 —— 任何范围都可以使用
    不同情形下可能具有不同的值
##  post变量
    $_POST：
        它代表用户通过表单提交的时候所提交的所有数据
    isset(变量)：判断变量是否存在或是否为空
    empty(变量)：判断变量的内容是否为空
##  计算器案例
    TODO
##  get变量
    代表用户通过get方式提交数据
    有4种get提交方式：
        方式1：
```html
            <from action="目标文件.php" method="get">
                <input type="text">
                <input type="text">
                <input type="text">
            </from>
```
            这种形式的get数据，跟post数据类似，数据内容由用户填写或选择而得到！
        方式2：
            <a href="目标文件.php?name=value"></a>
            它只是一个链接，只是在链接文件名后面加上“？”，然后拼上数据
            数据形式为：数据名称=数据值，数据之间用“&”拼接
            这种形式的数据也同样是提交的get数据，用户无法改变数据
        方式3：
            <script>
                location.href = "目标文件.php?name=value";
            </script>
            该语句可以看作是通过js技术实现的页面跳转功能
            起哄该语句，通常都是放在一个函数中，因为某个事件被触发
        方式4：
            <script>
                location.assign('目标文件.php?name=value');
            </script>
        方式5：
             <?php
                header("location: 目标文件.php?name=value")
             ?>
##  get数据获取
    TODO
##  request变量
    TODO
##  SERVER变量
    TODO
##  GLOBALS变量
    TODO
#   03
    开始第三天的学习
##  day2复习
    TODO
##  day2作业
    TODO
##  常量的定义和基本使用
    常量是相对于变量来说的：是一个其中存储的数据不会应不能改变的“标识符”
    常量的使用：定义、取值
    常量的定义：
        define('常量名', '值');
        const 常量名 = 值;
##  常量的其他细节
    常量与变量的区别：
        定义形式不同
        实用形式不同：常量不需要$符号
        可变程度不同：常量的值不可以改变，常量也不可以销毁
        作用范围不同：常量具有超全局作用域（函数内外都可以直接使用）
        可用类型不同：常量只能存储标量类型（整数、浮点数、字符串、布尔）
    判断常量是否存在：defined()函数，返回bool值
    使用一个未定义的常量：
        在php中，当使用一个未定义的常量的时候，系统会直接将该常量当作有值的常量去使用，并且其值就是该常量名（系统同时会报警告性错误）
    预定义常量：
        就是系统中预定义好的一些常量，大约有几百个
        M_PI：圆周率
        PHP_OS：php运行所在的操作系统
        PHP_VERSION：php版本号
        PHP_INT_MAX：php中最大的整数值
    魔术常量：
        其实只是常量的形式，但没有常量“恒常”的含义，其值其实会变化的，只是很少的几个：
            __FILE__：当前网页文件
            __DIR__：当前网页文件所在的目录
            __LINE__：当前这个常量名所在的行号
##  数据类型总体划分
    八种数据类型：
        基本类型（标量类型）：
            整数类型：int integer
            浮点数类型：float double
            字符串类型：string
            布尔类型：bool boolean
        复合类型：
            数组：array
            对象：object
        特殊类型：
            空类型：null
            资源类型：resource
##  进制转换的系统函数1
    整数类型：
        整数类型的3种写法：
```php
            $n1 = 123;
            $n2 = 0123; // 八进制数字写法
            $n3 = 0x123; // 十六进制数字写法
            $n4 = 0b1010; // 二进制数字写法
```
    进制转换问题：
        bin：2进制
        oct：8进制
        dec：10进制
        hex：16进制
    进制转换主要分2种情况：
        10进制转换为其它进制：
            10转2：decbin()
            10转8：decoct()
            10转16：dechex()
        其它进制转换为10进制：
            2转10：bindec()
            8转10：octdec()
            16转10：hecdec()
##  进制转换的系统函数2
    TODO
##  进制基础知识
    TODO
##  十进制转换为其他进制
    TODO
##  其他进制转换为十进制
    TODO
##  浮点数的两种表现形式
    浮点数的2种表现形式“
        常规写法：$v1 = 123.456;
        科学计数法：123.456E3
##  整数的细节深入知识
    浮点数使用的细节知识：
        浮点数不应进行大小比较
        小数转2进制的做法：乘2并顺序取整数部分
        当整数运算的结果超出整数的范围后，会自动转换为浮点数
##  字符串
    字符串形式：
```php
        $str1 = '字符串';
        $str2 = "字符串";
$str3 = <<<"A"
字符串
A;
$str4 = <<<A
字符串
A;
//
```
##  布尔类型
    只有两个数据：true、false
    只有如下数据是被当作“假”（false）：
        0，0.0，""，"0"，null，array()，false，未定义的变量
    其余都是真
##  自动类型转换
    自动转换：
        在任何运算中，如果需要某种类型的数据，而给出的数据不是该类型，通常都会发生自动转换，将该类型转换为目标需要的类型
        是由“运算符”或类似运算符的语句来决定的
##  强制转换
    强制转换：
        形式：(目标类型)数据
        含义：将该数据转换为设定的目标类型
        通常：
            (int)
            (string)
            (float)
            (bool)
            (array)
        上述强制类型转换，并不改变该变量的本身数据或类型，对应有一个函数是直接改变变量的类型：
            settype(变量, '类型');
##  有关类型的系统函数
    类型相关的函数：
        var_dump()：用于输出变量的“完整信息”，几乎只用于调试代码
        getType()：获取该变量的类型名字
        setType()：将变量强制改变为目标类型
        isset()：
        empty()：
        unset()：
        is_xx类型系统函数：判断某个数据是否为某种类型
#   04
    学习第四天的知识
##  day3复习
    TODO
##  day3作业
    TODO
##  算术运算符：基本、字符串自增
    基础：
        符号有：
            +
            -
            *
            /
            %
        说明：
            他们都是针对数字进行运算
            如果存在不是数字的数据，就会自动转换为数字
            其中取余运算（取模）%，它只针对整数进行运算，如果不是整数会自动截取为整数
    自增自减运算符：
        ++
        --
        常规：对数字进行自加1或减1
        字符串：只能自增，效果就是下一个字符
        布尔值递增递减无效
        null递减无效，递增结果为1
##  自加运算
    TODO
##  比较运算符基本0 
    符号：
        >
        >=
        <
        <=
        ==
        !=
        ===
        !==
    一般比较：是针对数字进行的大小比较
    ==和===比较：前者通常叫做模糊相等的比较，后者叫做精确相等的比较（只有数据的类型和数据的值都相等，才是全等的）
    不要对浮点数直接进行大小比较
##  不同类型数据之间的比较
    如果比较的数据中，有布尔值，转为布尔值比较，true > false
    有数字值，就转为数字值比较
    两边都是纯数字字符串，转为数字比较
    否则就按照字符串比较
##  逻辑运算符
    逻辑运算符都是针对“布尔值”进行的运算，如果不是布尔值也会自动转换为布尔值
    基本运算规则（真值表）：
        逻辑与规则：
            true  &&  true  === true
            true  &&  false === false
            false &&  true  === false
            false &&  false === false
        逻辑或规则：
            true  ||  true  === true
            true  ||  false === true
            false ||  true  === true
            false ||  false === false
        逻辑非规则：
            !true  ===  false
            !false ===  true
    逻辑运算符的“短路现象”
        如果一个判断语句中，通过逻辑运算需要进行多项判断，而且不同的判断具有不同的复杂程度，则应该将简单的判断放在前面，就可以利用“短路”现象提高效率
##  连接、赋值、条件运算符
    字符串运算符：
        符号只有一个：“.”，衍生为“.=”;
        含义：就是将两边的字符串连接起来
        如果两边不是字符串，就会自动转换为字符串，然后连接起来
    赋值运算符：
        一个基本赋值运算符：“=”
        衍生：
            +=
            -=
            *=
            /=
            %=
    条件（三目、三元）运算符：
        只有一个，形式：
            数据值1 ? 数据值2 : 数据值3
        含义：
            对数据值1进行逻辑判断，如果为“真”，则该运算符的运算结果是数据值2，否则就是数据值3
##  位运算符基础
    基础规定：
        位是什么？就是2进制数字的每一个“位”，一个整数数字，有（由）32个位构成
        位运算符是仅仅针对整数进行的运算符
        位运算符有：
            &：按位与
            |：按位或
            ~：按位非、按位取反
            ^：按位异或
        位运算符的基本语法规则：
            按位与基本规则：
                1 & 1 === 1
                1 & 0 === 0
                0 & 1 === 0
                0 & 0 === 0
            按位或基本规则：
                1 | 1 === 1
                1 | 0 === 1
                0 | 1 === 1
                0 | 0 === 0
            按位非基本规则：
                ~1 === 0
                ~0 === 1
            按位异或基本规则：
                1 ^ 1 === 0
                1 ^ 0 === 1
                0 ^ 1 === 1
                0 ^ 0 === 0
##  按位与运算
    整数的按位与运算（&）：
        形式：
            $n1 & $n2; // n1，n2是两个整数
        含义：
            将该两个整数的2进制数字形式的每一个对应位上的数字进行基本按位与运算之后的结果
##  按位或运算、按位左移运算
    整数的按位或运算（|）：
        形式：
            $n1 & $n2; // n1，n2是两个整数
        含义：
            将该两个整数的2进制数字形式的每一个对应位上的数字进行基本按位与运算之后的结果
    整数的按位左移运算：
        含义：
            $n1 << $m
        形式：
            将数字n1的二进制数字形式（32位）的每一个位上的数字都一次性往左边移动m位，并将右边空出的位置补0，左边多出的不管，这样操作之后的结果
##  原码、反码、补码介绍
    原码：
        就是一个二进制数字，从“数学观念”上来表达出的形式，其中规定：
            一个数字的最左边一位是“符号位”，0表示正数，1表示负数
    反码：
        正数的反码就是其本身，不变
        负数的反码是符号位不变，其余位取反
    补码：
        正数的补码就是其本身，不变
        负数的补码是符号位不变，其余位取反后+1
        
    5：
        原码：00000000 00000000 00000000 00000101
        反码：00000000 00000000 00000000 00000101
        补码：00000000 00000000 00000000 00000101
    -3：
        原码：10000000 00000000 00000000 00000011
        反码：11111111 11111111 11111111 11111100
        补码：11111111 11111111 11111111 11111101
    
    计算机内部的运算实际全都是使用补码进行的，而且运算的时候，符号位不再区分，直接也当作数字参与运算：
    5+3：
        00000000 00000000 00000000 00000101 + 00000000 00000000 00000000 00000011 = 00000000 00000000 00000000 00001000 // 2的3次方为8
    5-3:
        00000000 00000000 00000000 00000101 + 11111111 11111111 11111111 11111101 = 00000000 00000000 00000000 00000010 // 2的1次方为2
##  管理一组开关状态1
    什么是开关状态？
        现实中，有很多数据都是只有2种结果，对应的就是布尔类型
    这里所谓管理一组事物的开关状态，应该理解为其实就是管理若干个只有2个状态的“数据符号”
        比如，有5个灯泡，对应5个状态数据
        这5个灯泡，就有2⁵种状态
    这里的管理目标是使用一个变量，就可以表达若干个数据的“当前状态”
##  管理一组开关状态2
    TODO
##  数组运算符、错误控制运算符、运算符的优先级
    数组运算符：
        +：将右边的数组项合并到左边的数组后面，得到一个新数组，如果有重复键，则结果以左边为主
        ==：如果两个数组具有相同的键和值，可以顺序不同，类型不同，返回true
        !=：
        ===
        !==
    错误控制运算符：
        @：通常用在连接数据库语句上，在语句前加上@符号，如果连接数据库失败，就屏蔽失败的错误提示
    运算符的优先级：
        要意识到运算符有优先级
        括号最优先，赋值最落后
        先乘除后加减
        大致：单目运算符 > 算术运算符 > 比较运算符 > 逻辑运算符（除了“非”运算）
##  流程控制之流程图
    TODO
##  分支结构
    if分支结构：
        if (条件判断1) {
            分支1;
        } else if (条件判断2) {
            分支2;
        } else {
            else分支
        }
    switch分支结构：
        switch (表达式) {
            case 值1：
                分支1;
                break; // 可以省略
            case 值2：
                分支2;
            ......
            default:
                default 分支;
        }
##  for循环结构
    for循环结构：
        for($i = 1; $i <= 9; ++$i) {
            代码块
        }
#   05
    学习第五天的知识
##  day4复习
    TODO
##  day4作业（星星图案）
    TODO
##  day4作业（百钱百鸡）
    TODO
##  循环的中断
    break:用于完全终止某个循环，让执行流程进入到循环语句后面的语句
        break n：中断第n层的循环
    continue：用于停止正在进行的当前循环，直接进入下一次循环
        continue n：跳过第n层的当前循环，进入第n层的下一次循环
##  do while循环，循环3要素
    TODO
##  控制脚本运行进度
    TODO
##  文件加载初步，路径问题
    文件加载：
        综述和基本语法：
            有4个文件加载语句：
                include
                require
                include_once
                require_once
            他们的使用形式完全一样
            潭门的含义几乎完全一样，只有在加载失败时或是否重复加载这种情况有所不同
        文件加载的路径问题：
            有三种路径形式可以使用：
                相对路径：
                    是相对于当前网页文件所在的位置来定位某个被加载的文件位置
                绝对路径：
                    本地绝对路径：从系统磁盘开始
                    网络绝对路径：从网站根目录开始
                无路径：只给出文件名
##  文件载入详细过程
    文件载入和执行过程详解：
        从include语句处退出php脚本模式（进入html代码模式）
        载入include语句所设定的文件中的代码，并执行之
        退出html模式重新进入php模式，继续执行之后的代码  
##  四个载入语句的区别
    include和require的区别：
        include载入文件失败时（即没有找到该文件），报一个“提示错误”，然后继续执行后续代码
        require载入文件失败时，报一个“致命错误”，终止代码
    include和include_once的区别：
        include载入的文件不判断是否载入过，include_once只载入一次
##  被载入文件的返回值及return的作用
    TODO
##  错误分类
    通常分三种：
        语法错误：程序运行之前，都要先检查语法，如果语法有错，会立即报错并终止执行
        运行时错误：就是在程序语法检查通过后，开始运行程序并在此过程中遇到的错误
            提示性错误：
            警告性错误：
            致命错误：
        逻辑错误：指的是程序本身可以正常执行，没有报错，但“计算结果”错了
##  错误分级
    php语言中，将各种错误进行了不同级别的分类归纳，并形成大约有十几个级别的错误，这就是技术层面的错误分级
    每一级别的错误都有一个系统常量：
        系统常见错误：
            E_ERROR：致命错误
            E_WARNING：警告性错误
            E_NOTICE：提示性错误
        用户可自定义的错误：
            E_USER_ERROR：自定义致命错误
            E_USER_WARNING：自定义警告性错误
            E_USER_NOTICE：自定义提示性错误
        其它：
            E_STRICT：严谨性语法检查错误
            E_ALL：代表所有错误
##  错误触发
    有两种方式触发错误：
        系统触发：程序运行到某处代码出现了某种错误，此时系统就会报错
            E_ERROR：致命错误：导致程序无法执行后续语句
                比如调用一个不存在的函数
            E_WARNING：警告性错误：会输出错误提示，并继续执行后续代码（也可能看具体情况）
            E_NOTICE：提示性错误：会输出错误提示，并继续执行后续代码
                比如使用不存在的常量或变量
        自定义触发：
##  是否显示错误报告
    错误报告的显示问题：
        是否显示错误报告：
            php.ini中，设定display_errors的值，on，off
            直接在php中通过ini_set('display_errors', '0')设置
        显示哪些级别的错误报告
##  显示哪些级别的错误
    TODO
##  错误日志记录问题
    是否记录：
        在php.ini中，设置log_error = on 或 off
        在php中，通过ini_set('log_error', '0')设置
    记录到哪里：
##  自定义错误处理器
    TODO
#   06
    学习第六天的知识
##  day5复习
    TODO
##  day5作业
    TODO
##  函数初步，函数参数问题
    函数基础：
        函数的定义：
            形式：
                function 函数名 (形参1,形参2,......) {
                    函数体
                }
            说明：
                定义对使用的形参，其实就是一个变量，只能在函数内部使用的变量
                形参作为变量
        函数的调用：
            形式：
                函数名 (实参1,实参2,......)
            说明：
                实参应该要与调用的函数的形参一一对应
                实参就是形参的值
        函数调用的详细过程：
            寿险将函数调用时的实参数据，传递（赋值）给函数的形参
            程序的执行流程，进入函数内部运行函数体代码
            在函数内部，按正藏的流程顺序，执行其中的代码
            直到函数结束，则退出该函数内部，返回到调用函数的位置往下执行代码
            如果在函数内部执行的过程中，有return语句，则会立即终止函数内部的执行，并返回数据到函数调用位置
        函数的参数问题：
            函数形参的默认值问题：
                可以给一个函数定义时的形参赋值一个“默认值”，则这个函数被调用时，对应的实参可以不传
            形参的传值问题：
                值传递：
                引用传递：
##  函数参数的数量问题
    通常，函数调用时的实参数量应该与被调用的函数定义的形参数量一直
    如果函数定义时，形参有默认值，则调用该函数传递的实参数量可以省略有默认值的形参
        注意，省略只能有后往前
    有一种定义函数的特别形式（并不常见），它不定义形参，而实参任意给出
##  函数的返回值问题
    函数的返回值不受语法规定，根据需求，需要返回就return，不需要就不return
##  可变函数及应用
    可变变量：
```php
        $v1 = 'abc';
        $abc = 123;
        echo $$v1;
```
    可变函数：
```php
        function f1() {
            echo '<br/>';
        }
        $v1 = 'f1';
        $v1();       
```
        这就是可变函数
        可变函数其实就是在调用函数的时候，使用一个变量名
        该变量的值就是函数名
##  有关可变函数和函数的概念复习
    TODO
##  匿名函数
    匿名函数就是没有函数名的函数
    有两种形式：
        将一个匿名函数赋值给一个变量，此时该变量就代表该匿名函数
        直接将一个匿名函数当作实参来使用，即调用其它函数的时候，使用一个匿名函数当作实参，在被调用的函数内部使用该匿名函数
##  匿名函数再解释
    TODO
##  不同的作用域和对应的不同变量
    变量的作用域：
        一个变量，在什么范围中可以使用的情况
    php中，有三种变量作用域：
        局部作用域：就是指一个函数内部的范围
        全局作用域：在函数外部定义的不能被函数内部使用，可以被函数外部的代码使用
        超全局作用域：就是指所有的代码范围
##  局部使用全局变量做法1
    在函数内部使用函数外部的全局变量，需要在变量名前加上global关键字，声明变量是全局变量
```php
        $v1 = 4;
        function v1() {
            global $v1;
            echo $v1;
            $v1 = 44;
        }
        echo $v1; 
```
##  局部使用全局变量做法2
    使用$GLOBALS超全局变量
##  函数的一般知识
    有关函数的系统函数：
        function_exists(函数名)：判断一个函数是否被定义过
        func_get_arg()：
        func_get_args()：
        func_num_args()：
    其它系统函数：
        字符串函数：
        时间函数：
        数字函数：
##  递归思想
    递归思想——递归函数
    在一个函数内部调用函数本身，并且可以控制的就是递归
    当面对一个“大问题”，该大问题可以经由该问题的同逻辑问题的“小一级”问题而经过简单计算获得，而且可以获知这类问题的最小一级的答案
##  递归再演示和总结
    TODO
##  递推思想演示
    递推（迭代）思想
    一般以循环的形式实现
    如果要求一个“大问题”，且该问题有如下两个特点：
        已知该问题的同类问题的最小问题的答案
        如果知道这种问题的小一级问题的答案，就可以轻松求得其“大一级”问题得答案，并且此问题得级次有一定的规律
#   07
    学习第七天的知识
##  day06复习
    TODO
##  day06作业
    TODO
##  数组初步
    数组：
        数组基础：
            数组定义（赋值）：
                $arr = array(1, 2, 3, 4, 5); // 这是最常见的数组（枚举、索引数组），下标为默认下标，从0开始的数组
                $arr = array('a' => 1, 'b' => 2, 'c' => 3, 'd' => 4, 'e' => 5); // 这是关联数组，下标为字符串，人为定义
                下标可以人为定义
                下标可以由数字和字符串混合
                没有给出下标的数据项会以前面数据项中最大的数字下标加一为下标
                小数小标会自动向下取整
                下标如果有重复，后面的数据项会覆盖前面的数据项
            数组取值：
        数组的分类：
            按键值关系来分：
                索引（枚举）数组：数组下标严格从0开始
                关联数组：数组下标都是“字符串”且命名上具有含义
                混合数组：既有数字下标，也有字符串下标
            按数组的维数（复杂程度）来分：
                一维数组：
                    $arr = array();
                二维数组：
                    $arr = array(
                        array();
                    );
                多维数组：
##  数组常见使用
    TODO
##  有关数组交换的补充解释
    TODO
##  数组的基本遍历和指针操作
    数组的遍历：
        foreach基本语法：
            foreach (数组 as [$key =>] $value) {
                // []内可以省略
                // 循环体代码
                // $key是每个单元项的下标
                // $value是每个单元项的值
            }
    数组的指针操作及遍历原理：
        正常情况下数组的指针从第一项单元开始
        数组作为一个“总体数据单位”，有如下指针操作函数：
            current(数组)：获取数组当前指针所在单元的值
            key(数组)：获取数组当前指针所在的键
            next(数组)：将数组的指针移向下一个单元并返回所在单元的值
            prev(数组)：将数组的指针移向上一个单元并返回所在单元的值
            end(数组)：将数组的指针移向最后一个单元并返回所在单元的值
            reset(数组)：将数组的指针移向第一个单元并返回所在单元的值
##  数组遍历原理图
    TODO
##  for、next遍历数组
    TODO
##  each()函数的作用
    each()函数的作用，先取得数组当前单元的键值并放入一个新数组，然后将指针移向下一个单位
    新数组中有四个单元，键分别是0、1、key、value，0和key的值是each取得的键值中的键，1和value的值是each取得的键值中的值
##  while、each、list遍历
    list()函数的使用：
        list(变量1,变量2,......) = 数组
        根据list中的变量数量，取得枚举数组中从第一个单元开始往后相同数量的值，并于变量一一对应，变量数量不能超过数组
##  foreach遍历细节探讨
    foreach是正常的循环语法结构，可以有break和continue等操作
    遍历过程中值变量默认的传值方式是值传递
    遍历过程中值变量可以人为设定为引用传递
    foreach默认是原数组上进行遍历，但如果在遍历过程中对数组进行了某种修改和某种指针性操作，则会复制数组后在复制的数组上继续遍历循环
    在foreach中如果值变量是引用传递，则无论如何都是在原数组上进行
##  数组排序函数的应用
    TODO
##  冒泡排序
    TODO
##  选择排序
    TODO
#   08
    学习第八天的知识
##  day7复习
    TODO
##  day7作业
    TODO
##  二分查找
    TODO
##  MySQL介绍
    数据库是什么：
        数据库分类：
            层次数据库
            网状数据库
            关系数据库
        主流数据库：MySQL、SQL Server、Oracle
        SQL：这是关系数据库的“语言标准”，struct query language（结构化查询语言）
    数据存储的本质和表现：
        数据库系统 （一对多） 数据库
        数据库 （一对多） 数据表
        数据表 （一对多） 数据行（记录）
        数据行（记录） （一对多） 数据项（字段）
    基本概念：
        数据（data）
        数据库（database）：用于存储一个项目相关的各种数据的一个逻辑单位
        数据库管理系统（DBMS）：数据库系统的软件产品
        数据表（table）：用于存储数据的文件
        字段（field），列（column）：一个数据表中一个纵列的名字
        行（row），记录（record）
##  数据库系统基本操作
    启动/停止mysql数据库服务：
        命令行模式：
            启动：net start mysql
            停止：net stop mysql
        服务模式：
            控制面板 -> 管理工具 -> 服务 -> mysql -> 启动服务
    登录/退出mysql系统
        登录：
            mysql -h 服务器地址 -u 登录名 [-p 端口号] -p
            mysql --host=服务器地址 --user=用户名 --port==端口号 --password
        退出：
            quit;
            exit;
    注意：登录数据库系统后，需要使用“set names 编码名;”来设定当前连接数据库系统的“环境编码名”
    数据库的备份与恢复
        备份：就是将一个数据库，完整地转换为一个可以随时携带和复制的文件
            mysqldump -h 服务器地址 -u 登录名 -p 数据库名 > 文件名
        恢复：将一个备份的文件完整地还原为数据库
            mysql -h 服务器地址 -u 登录名 -p 数据库名 < 文件名
        注意：
            这两个命令，都是在没有登录进入数据库的时候使用
            其中备份命令还要求为管理员身份
##  基本语法规定
    注释：
        单行注释：#注释内容
        单行注释：-- 注释内容
        多行注释：/* 注释内容 */
    语句行：
        默认情况下，以一个英文分号作为一条语句的结束
    大小写问题：
        mysql语言内部本身不区分大小写，但mysql的某些命令执行文件（夹），此时可能会区分大小写：
            在区分文件（夹）名称大小写的系统中，这些名字也会区分大小写，比如unix，linux系统
            在文件（夹）名称不区分大小写的系统中，这些命令也不区分，比如windows
    命名问题：
        可以自己命名的名字。称为标识符，包括：数据库名、表名、字段名、视图名、函数名、过程名、变量名、用户名
        可以命名标识符的字符比常规的语言多，但建议只用字母数字和下划线且不用数字开头
        非常规字符或系统关键字虽然可以作为标识符使用，但最好包在反引号中
        对数据库名，表名和视图名，在window系统中不区分大小写，而其他系统中区分，建议全使用小写
        对其它自己命名的标识符，不区分大小写，但建议小写，并使用下划线分割法
##  创建数据库及有关编码问题
    数据库定义语句：
        创建数据库：
            create database 数据库名 [charset 字符编码名称] [collate 排序规则]
                字符编码名称是用于设定当前数据库中存储的字符内容的编码格式
                collate排序规则用于设定其中的字符内容的“大小/先后”关系
##  数据库的其它操作
    删除数据库：
        drop database [if exists] 数据库
        删除数据库，[如果数据库不存在，也不会报错]
    现实所有数据库：
        show database
    显示一个数据库的创建语句
        show create database 数据库名
    进入数据库
        use 数据库名
##  数据类型总览
    字段类型（数据类型）
        总览：mysql中，数据类型主要分三大类：数字型，字符型，时间型
##  整数
    整数类型：
        int：占4个字节，即32位
        tinyint：占1个字节，即8位，最多存储256个数字，默认范围是-128~127
        smallint：
        bigint：占8个字节，即64位
    整数类型字段的设定形式：
        类型名 [M] [unsigned] [zerofill]
        M表示设定该整数的显示长度，即select输出的时候，123可能显示为000123，假设M为6
        unsigned用于设定该整数为“无符号数”，其实就是没有负数
        zerofill用于设定是否填充“0”到一个数字的左边，此时，需要与设定的长度M配合使用
##  小数类型
    float：单精度浮点型，使用4个字节存储数据，其精度大约只有6-7个有效数字数位
    double：双精度浮点型，使用8个字节存储数据，其精度大约20个有效数字数位
    decimal：定点小鼠类型，整数部分最长可以存65位，小数部分最长可以存储30位，一般设置格式为decimal(整数部分位数,小数部分位数)
##  php操作数据库的知识点复习
    $link = mysql_connect('数据库服务器地址', '用户名', '密码'); // 连接数据库
    mysql_query('set names 网页文件编码名'); // 设定连接编码 mysql_set_charset('网页文件编码名')
    mysql_query('use 数据库名'); // 选定要使用的数据库 mysql_select_db('数据库名')
##  php操作数据库的扩展知识
    TODO
#   09
    学习第九天的知识
##  day8复习
    TODO
##  day8作业
    TODO
##  phpmyadmin的配置
    TODO
##  varchar、char类型
    字段类型：
        字符类型：
            varchar：可变长度字符串，使用时必须设定其长度，理论最大长度65535，实际最大长度65533，但根据存储的字符编码不同，也会有进一步减少，如中文gbk编码，最多56633/2个，若utf8，则最多65533/3
            char：定长字符串，使用时通常需要设定存储长度，如果不设定，默认是1，最大长度255个，定长字符串适用于存储的数据都是可预见的明确的固定长度的字符，比如手机号，中国邮政编码，实际存储的时候，如果少于设定长度，也能存，但都会补空格填满
##  enum、set类型
    字符类型：
        enum：单选项字符串数据类型，非常适合于存储表单界面中的“单选项值”，设定的时候，需要给定“固定的几个选项”，然后存储的时候，就只存储其中一个值，如enum("选项1", "选项2", "选项3", ...)，实际内部这些字符串选项对应的是如下数字值1、2、3，最多可以有65535个选项
        set：多选项字符串数据类型，非常适合于存储表单界面中的“多选项值”，设定的时候，需要给定“固定的几个选项”，然后存储的时候，可以存储若干个值，这些字符串选项值对应的是1、2、4、8....，最多64个选项
        text：长文本字符类型，存储的数据不占据表格中的数据限制，最长可存储65535个字符，其它同类型字符类型：smalltext、tinytext、longtext
        其它：
            binary：定长二进制字符串类型，存储的是二进制值
            varbinary：变长二进制字符串类型，存值的是二进制值
            blob类型：二进制数据类型，存的仍然是二进制值，但其适用于存储图片等文件
##  时间日期类型
    常用的时间类型：
        datetime：时间日期类型
        date：日期类型
        time：时间类型
        year：年份类型
        timestamp：时间戳类型，就是指一个时间的“UNIX数据值”，本质是一串数字，重要作用是会自动获取当前的时间戳
##  表创建语句形式及属性形式
    表定义语句：
        创建表：
            基本语法形式：
                create table [if not exists] 表名 (字段列表 [, 索引或约束列表])[表选项列表]
            字段设定形式：
                字段名 类型 [字段属性列表]
                    字段名可以自己取
                    类型就是数据库数据类型
                    字段属性根据具体的需要可以有多个，相互之间空格隔开：
                        auto_increment：只用于整数类型，让该字段的值自动获得一个增长值
                        primary key：用于设定该字段位为主键，该字段的值唯一确定
                        not null：该字段不能为空
                        default xxx值：用于设定该字段的默认值
                        comment：字段说明文字
                        unique key：设定该字段中的值唯一
##  索引基本概念及用法
    什么是索引？
        索引是系统内部自动维护的隐藏的“数据表”，可以极大地加快数据的查找速度！
        这个隐藏的速度表，其中的数据是自动排好序的，其查找速度建立在这这个基础上
    建立索引
        指定一个表的某些字段作为“索引数据字段”
        索引类型(字段名)：
            key：普通索引类型，就是一个索引而已，没有其它作用，只能加快查找速度
            unique key：唯一索引类型，可以设定其字段内的值唯一，不能重复，可以为空
            primary key：主键索引类型，具有区分该表中的任何一行数据的作用（记录唯一性），不能为空
            fulltext：全文索引类型
            foreign key：外键索引类型，foreign key (字段名) references 其他表中的字段名
##  外键索引
    TODO
```
        CREATE TABLE IF NOT EXISTS banji(
        	id INT AUTO_INCREMENT,
        	banjihao VARCHAR(10) COMMENT '班级号',
        	banzhuren VARCHAR(10) NOT NULL COMMENT '班主任',
        	open_date DATE COMMENT '开班日期',
        	PRIMARY KEY(id),
        	UNIQUE KEY(banjihao)
        ) ENGINE=InnoDB;
        
        CREATE TABLE IF NOT EXISTS xuesheng(
        	id INT AUTO_INCREMENT,
        	name VARCHAR(10) COMMENT '姓名',
        	age TINYINT,
        	banji_id INT COMMENT '班级id',
        	PRIMARY KEY(id),
        	FOREIGN KEY(banji_id) REFERENCES banji(id)
        ) ENGINE=InnoDB;
```
##  百万计数据的索引演示
    TODO
##  约束
    什么叫约束？
        约束就是要求数据需要满足什么条件的一种规定
    约束的种类：
        主键约束：primary key(字段名)
            含义：使该设定字段的值可以用于“唯一确定一行数据”，其实就是主键的意思
        唯一约束：unique key(字段名)
            含义：使该设定字段的值具有“唯一性”
        外键约束：foreign key(字段名) references 其它表名(字段名)
            含义：使该设定字段的值，必须在其设定的对应表中的对应字段已经有该值了
        非空约束：not null，其实就是设定一个字段不能为空
        默认约束：default '默认值'，设定一个字段为空时的默认值
        检查约束：check (判断语句)，设定字段的值必须符合判断语句的要求
##  表选项
    表选项就是创建一个表的时候，对该表的整体设定，主要有如下几个：
        charset：要使用的字符编码
        engine：要使用的存储引擎（也叫表类型），设定的字符编码是为了跟数据库设定的不一样，如果一样，就不需要设定了，因为其会自动使用数据库级别的设定
        auto_increment：设定当前表的自增长字段的初始值，默认是1
        comment：该表的一些文字说明
##  修改表
    创建表能做的事，修改表几乎都能做
    不推荐修改表，在创建表的时候应该确定好表的结构
        可以对字段进行添加、删除、修改
        可以对索引进行添加、删除
    常见操作：
        添加字段：alter table 表名 add [column] 新字段名 字段类型 [字段属性列表]
        修改字段：alter table 表名 change [column] 旧字段名 新字段名 新字段类型 [新字段属性列表]
        删除字段：alter table 表名 drop [column] 字段名
        添加普通索引 alter table 表名 add key [索引名] (字段名1[, 字段名2, 字段名3, ......])
        添加唯一索引：alter table 表名 add unique key [索引名] (字段名1[, 字段名2, 字段名3, ......])
        添加主键索引：alter table 表名 add primary key [索引名] (字段名1[, 字段名2, 字段名3, ......])
        修改表名：alter table 旧表名 rename [to] 新表名
##  表的删除及其它相关语法
    显示当前数据库中的所有表：show tables
    显示某表的结构：desc 表名 / describe 表名
    显示某表的创建语句：show create table 表名
    重命名表：rename table 旧表名 to 新表名
    从已有表复制表结构：create table [if not exists] 新表名 like 被复制表名
##  视图
    什么叫视图？
        就是被封装起来的SQL语句的代码 —— 函数。
    视图的创建语句：
        create view 视图名 as select语句
        create view v1 as select id, f1, name, from 表1 where id > 7 and id < 100 and or f1 < 10000 and age > 10;
    使用视图：
        基本上当作一个表用
        select * from v1;
    删除视图：
        drop view [if exists] 视图名
#   10
    学习第十天的知识
##  day09复习
    TODO
##  day09作业
    TODO
##  数据库设计三范式
    第一范式（1NF）：
        原子性：使数据不可再分
    第二范式（2NF）：
        唯一性：使每一行数据具有唯一性，并清除数据之间的“部分依赖”（只要给表设定主键，就可以保证唯一性）
            依赖：就是在一个表中，其中某个字段B的值可以由另一个字段A的值来决定，此时字段B依赖于字段A，一般来说主键决定其它字段，其它字段依赖于主键
            部分依赖：如果某个字段只依赖于“部分主键”，就是部分依赖（这种情况是因为表中有多个主键）
            完全依赖：某个字段依赖于“主键的所有字段”（如果一个表只有一个主键字段，则必然是完全依赖）
    第三范式（3NF）：
        独立性：消除传递依赖，使每个字段都独立于依赖主键字段，要消除其中部分非主键字段的内部依赖（将部分依赖的几个字段单独建一个表）
            传递依赖：某些字段除了依赖于主键字段，还会依赖于其它某些字段
##  插入语句语法
    插入数据（增）：
        多种语法形式：
            insert [into] 表名[(字段名1, 字段名2, 字段名3, ......)] values(值表达式1, 值表达式2, 值表达式3, ...),(......),.....
                这是最常用的插入语句，可以一次性插入多行数据，用逗号隔开
                插入语句，可以理解为每次插入数据都是以“行”为单位插入
                字段名通常不推荐省略，其后续的“值列表”应该跟字段名列表“一一对应”
                其中的值表达式，可以是一个“直接的”，或“函数调用结果”，或变量值，其中如果对应字段使字符或者时间类型，则直接值应该使用单引号
            replace [into] 表名[(字段名1, 字段名2, 字段名3, ......)] values(值表达式1, 值表达式2, 值表达式3, ...),(......),.....
                与形式1几乎一样，唯一区别是如果插入的数据的主键或唯一键“有重复”，则此时就会变成“修改该行数据”
            insert [into] 表名[(字段名1, 字段名2, 字段名3, ......)] select 字段名1, 字段名2, 字段名3, ...... from 其它表名
                将select语句查询结果的数据（可能多条）都插入到指定的表中
                其中也需要字段的对应
            insert [into] 表名 set 字段名1 = 值表达式1, 字段名2 = 值表达式2, 字段名3 = 值表达式3, ......
##  load data载入数据语句
    TODO
##  数据删除和修改
    删除数据（删）：
        语法形式：
            delete from 表名 [where 条件] [order by 排序] [limit 限定]
        说明：
            删除数据仍然是以“行”为单位进行
            通常删除数据都需要带where条件，否则删除所有数据
            where条件的语法跟select中的语法一样
            order by排序设定，用于指定这些数据的删除顺序，它通常跟limit配合使用才有意义
            limit限定用于设定删除多少行
            实际应用中，通常很少用到order by和limit
    修改语句（改）：
        语法形式：
            update 表名 set 字段1 = 值1, 字段2 = 值2, 字段3 = 值3, ......[where 条件] [order by 排序字段] [limit 限定行数]
        说明：
             通常，update语句也都需要where条件语句，否则就会修改所有数据
             where条件的语法跟select中的语法一样
             order by排序设定，用于设定修改的顺序，limit用于设定修改的行出，他们通常结合使用
             注意，其中的数据值，如果是字符串和时间类型的直接值，就应该使用单引号
##  字段或表达式，all和distinct
    基本查询：
        基本语法形式：
            select [all | distinct] 字段或表达式列表 [form 子句] [where 子句] [group by 子句] [having 子句] [order by 子句] [limit 子句]
        字段或表达式列表：
            字段，自然是来源于“表”，必然依赖于from子句
            表达式是类似于这样一个内容：8、8+3、now()
        all和distinct：
            用于谁当select出来的数据是否消除“重复行”
                all：不消除，所有都取出来
                distinct：消除
##  from子句
    TODO
##  where子句
    TODO
##  is运算符
    空值和布尔值的判断
    四种情况：
        is null：判断某个字段是null
        is not null：判断某个字段不是null
        is true:判断某个字段为真
        is false:判断某个字段为假
##  between和in运算符
    between运算符：范围判断
        用于判断某个字段的数据是否在某个特定的范围之间
        between 值1 and 值2
        字段的值给定在值1和值2之间，大于等于值1，小于等于值2
    in运算符：给定确定数据列表
        in (值1, 值2, 值3, ...)
##  like语法
    like运算符：对字段进行模糊查找
    like %要查找的内容%
        %：代表任何个数的任何字符
        _：代表一个任何字符
##  group by分组子句（1）
    group by：分组
        group by 字段1 [desc | asc, 字段2 desc | asc, ...]
        分组是对已经找出的数据根据排序字段进行的分组
        同时该分组结果可以同时指定其排序方式desc，asc
        通常，分组就一个字段依据
    什么叫做分组？
        分组，就是将多行数据，以一定的标准来进行分类存放
##  group by分组子句（2）
    TODO
##  having分组子句
    having的作用跟where一样，但其只对“分组的结果数据”进行筛选
##  order by排序子句
    用于将取得的数据进行排序
    order by 字段1 [desc | asc, 字段2 desc | asc, ......]
    对前面的结果数据以指定的一个或多个字段排序
    排序可以设定升序或降序，默认是升序
    多个字段的排序，都是在前一个字段排序号的基础上，前一个字段中有相等的数据按后一个字段的排序结果
##  limit限定子句
    用于将取得的数据结果按指定的行数取出来，从第几行开始取几行
    limit 起始行数 截取行数
    起始行数都是从0开始算起的，起始行号跟数据中的任何一个字段（比如id）没有关系
    截取行数也是数字，大于0
    简写：limit 截取行数：起始行数默认0
##  对select查询语句的总结
    TODO
#   11
    学习第十一天的知识
##  day10复习
    TODO
##  day10作业
    TODO
##  day10作业 —— 表单的一个改进
    TODO
##  连接基本概念和形式
    连接查询：
        基本概念：
            将两个或两个以上的表连接起来，当作一个表
            将每一个表的每一行数据两两之间连接起来，每次对接的结果就是连接结果的一行
        语法：
            select * from 表1, 表2 
            select * from 表1 join 表2 
            select * from 表1 cross join 表2
        连接基本形式：
            在代码级别，连接的基本形式为：
                表1 [连接形式] join 表2 [on 连接条件]
            如果是3个表：
                表1 [连接形式] join 表2 [on 连接条件] [连接形式] join 表3 [on 连接条件]
##  交叉连接
    连接的分类：
        交叉连接：
            起始就是基本的连接形式，没有条件，只是将所有数据行都连接起来的结果，叫做“笛卡尔积”
            对于表1（n1个字段，n2行），表2（m1个字段，m2行），它们交叉的结果是有n1*m1个列，n2*m2个行
##  内连接
     内连接：
        形式：select * from 表1 inner join 表2 on 连接条件
##  左连接、右连接、全连接
    左（外）连接：
        其实就是将两个表的内连接的结果，在“加上”左边表的不符合内连接所设定的条件的那些数据的结果
        表1（左表） left [outer] join 表2（右表） on 连接条件
    右（外）连接：
        其实就是将两个表的内连接的结果，在“加上”右边表的不符合内连接所设定的条件的那些数据的结果
        表1（左表） right [outer] join 表2（右表） on 连接条件
    全（外）连接：
        mysql不支持全连接的语法
        其实就是将两个表的内连接的结果，在“加上”左边表的不符合内连接所设定的条件的那些数据的结果以及左右边表的不符合内连接所设定的条件的那些数据的结果
        表1（左表） full [outer] join 表2（右表） on 连接条件
##  连接查询举例
    TODO
##  子查询基本概念
    基本含义：
        一个select语句就是一个查询语句：select 字段或表达式 from 数据源 where 条件判断语句
        上述select部分，from部分，where部分往往都是一些数据或数据的组合
        from部分当然就是表或表的连接结果，他们也是数据，只是通常为表数据
        所谓子查询，就是在一个查询语句中的内部的某些位置出现的另外一条完整的查询语句，则有两个概念：主查询，子查询
    在形式上：
        select 字段或表达式或子查询 [as 别名] from 表名或连接结果或子查询 where 字段或表达式或子查询的条件判断语句
##  子查询分类
    按子查询结果分为：
        表子查询：
            子查询的结果是一个多行多列的数据表
        行子查询：
            子查询的结果是一行多列的数据，通常放在“行比较语法”中：where row(字段1, 字段2) = (select 行子查询)
        列子查询：
            子查询的结果是多列一行的数据
        标量子查询：
            一个子查询返回的结果理论上是一行一列的时候，此时可以当作一个单个值使用
    按子查询位置分为：
        作为主查询的结果数据：
            select c1, (select f1 from tab2) as fl1 from tab1
        作为主查询的条件数据：
            select c1 from tab1 where c1 in (select f1 from tab2)
        作为主查询的来源数据：
            select c1 from (select f1 as c1, f2 from tab2) as t2
##  常用子查询
    比较运算符中的子查询：
        形式：
            操作数 比较运算符 (标量子查询)
        说明：
            操作数，其实就是比较运算符的2个数据之一而已，通常就是一个字段名
        举例：
            找出价格最高的所有商品：select * from product where price = (select max(price) from product)
    使用in的子查询：
        形式：
            操作数 in (列子查询)
        举例：
            找出所有类别名字中带“电”的所有商品：select * from product where id in(select id from product where name like '%电%')
    使用any的子查询：
        形式：
            操作数 比较运算符 any (列子查询)
        含义：
            当某个操作数对于该列子查询的其中任一个值，都满足该比较运算符，就算是满足了条件
        举例：
            表1中的id只要大于表2中的f1列中任意一个值：select * from tab1 where id > any (select f1 from tab2);
    使用all的子查询：
        形式：
            操作数 比较运算符 all (列子查询)
        含义：
            当某个操作数对于该列子查询的所有数据值全部都满足，就算是满足了条件
        举例：
            表1中的id必须大于表2中的id列中所有的值：select * from tab2 where f1 > all (select id from tab1)
    使用some的子查询：
        是any的同义词
##  exists子查询
    使用exists子查询：
        形式：
            where exists(子查询)
        含义：
            该子查询如果有数据，则exists的结果是true，否则是false
        举例：
            select * from where exists (select * from ta1);
        说明：
            因为，exists子查询的含义造成主查询往往出现要么全部出来数据要么都不取出，实际应用中，往往都不是独立的子查询，而是会需要跟主查询的数据源建立连接关系
##  联合查询
    union：
        基本概念：
            将两个具有相同字段数量的查询语句的结果，以上下堆叠的方式合并为一个查询结果，两个select语句的查询结果的字段数必须一致，通常也应该让两个查询语句的字段类型基本一致
        语法形式：
            select语句1 union [all | distinct] select语句2 union ......
        说明：
            联合查询语句默认会自动消除重复行数据，即distinct
    TODO
#   12
    学习第十二天的知识
##  day11复习
    TODO
##  day11作业
    TODO
##  用户管理
    数据控制语言：
        是用于对mysql的用户及其权限进行管理的语句
    用户管理：
        mysql的所有用户都存储在系统数据库mysql中的user表中
        创建用户：
            形式：create user "用户名"@"允许登录地址/服务器" identified by "密码"
            举例：create user 'user1'@'localhost' identified by '123456'
        删除用户：
            形式：drop user '用户'@'允许登录地址/服务器'
        修改用户密码：
            形式：set password for '用户名'@'允许登录地址/服务器' = password('新密码')
##  权限管理
    权限是什么？mysql数据库将其中所有的操作都分配到各个权限中。
    授予权限：
        形式：grant 权限列表 on 某库.某个对象 to '用户名'@'允许登录地址/服务器' [identified by '密码']
        说明：
            权限列表，多个权限的名词，相互之间用逗号分开，如：select, insert, update
            某库.某个对象，表示给指定的某个数据库中的某个“下级单位”授权
            下级单位有表名、视图名
            其中有两个特殊的语法：
                *.*：代表所有数据库中的所有下级单位
                某库.*：代表某库中的所有下级单位
            [identified by '密码']：如果授权的用户不存在，就需要设置用户密码
    剥夺权限：
        形式：revoke  权限列表 on 某库.某个对象 from '用户名'@'允许登录地址/服务器'
##  事务的基本概念和特点
    事务控制语言：
        什么叫事务？事务就是用来保证多条增删改语句的执行的连贯性和一致性，要么都完成要么都不完成
        事务的特点：
            原子性：一个事务的所有语句要么全做要么全部做
            一致性：让数据保持逻辑上的合理性
            隔离性：如果多个事务同时并发执行，但每个事务就像各自独立执行
            持久性：一个事务执行成功，则对数据来说应该是一个明确的硬盘数据更改
##  事务模式
    TODO
##  事务执行流程
    开启一个事务：start transaction;
    执行多条增删改语句
    判断这些语句执行的结果情况：
        if (没有出错) {
            commit; // 提交事务
        } else {
            rollback; // 回滚事务
        }
##  语句块包含符
    mysql编程：
        mysql编程中语句块包含符：
            [标识符: ]begin
                // 语句
            end[ 标识符];
##  流程控制
    if语句：if ... [elseif] [else] endif
    case语句：case 表达式 when 值 then 处理语句 [when ... then ...] [else ...] end case
    loop循环语句：
        标识符: loop 
            begin 
                // 循环语句块;
                if
                    leave 标识符; // 退出循环
                end if;
            end; 
        end loop
    while循环语句：
        while 条件 do
            // 循环语句块
        end while;
    repeat循环语句：
        repeat
            begin
                // 循环语句块
            end
            until 结束循环的条件
        end repeat;
##  变量
    mysql中有两种变量形式：
        普通变量：不带“@”符号：
            定义形式：declare 变量名 类型名 [default 默认值]; // 普通变量必须先这样定义
            赋值形式：set 变量名 = 值;
            取值形式：直接使用变量名
            使用场景：只能在编程环境中使用：定义函数的内部，定义存储过程的内部，定义触发器的内部
        会话变量：带“@”符号：
            定义形式：set @变量名 = 值; // 跟php类似，无需定义，直接赋值
            取值：直接使用变量名
            使用场景：基本任何地方都能用
    变量赋值的四种语法：
        set 变量名 = 值;
        set @变量名 = 值;
        select @变量名 = select语句;
        select select语句 into @变量名;
##  函数
    （存储）函数：函数也说成存储函数，这里的函数必须返回一个数据（值）
    定义形式：
        create function 函数名(形参名1 类型, 形参名2 类型, ......)
            returns 返回类型
            begin
                // 语句块
                return 返回数据；
            end;
    调用形式：
        跟调用内部函数一样，比如：select now()
        如果在编程语句中：set @v1 = func();
    举例：
        delimiter ///
        create function getMaxValue(p1 float, p2 float, p3 float)
            returns float
            begin
                declare result float;
                if (p1 >= p2 and p1 >= p3) then
                    begin
                        set result = p1;
                    end;
                elseif (p2 >= p1 and p2 >= p3) then
                    begin
                        set result = p2;
                    end;
                else
                    begin
                        set result = p3;
                    end;
                end if;
                return result;
            end;
        ///
        
        select now(), getMaxValue(1.5, 2.5, 3.5);
    删除函数：drop function 函数名
    注意：
        在函数内部，可以有各种变量和流程控制的使用
        在函数内部，也可以有各种增删改语句
        子啊函数内部，不可以有select或其他返回结果集的语句    
##  存储过程
    定义：
        create procedure 存储过程名(形参名1 类型, 形参名2 类型, ......)
            begin
                //语句块
            end;
    调用：call 存储过程名([in | out | inout ]实参名1 类型, [in | out | inout ]实参名2 类型, ......)
    举例：
    创建一个存储过程，目标是将3个数据写入到表tab并但会该表的第一个字段的前三个最大的值
    create procedure insert_get_data(p1 int, p2 int, p3 int)
        begin
            insert into tab(f1, f2, f3) values(p1, p2, p3);
            select * from tab order by f1 desc limit 3;
        end;
    call insert_get_data(1, 2, 3)
    注意：
        存储过程中写完整的过程中语句
        其中可以有各种流程控制
        还可以有增删改查等操作
        其中查询语句（select）会作为存储过程调用的结果，跟执行select语句一样，直接返回结果
        in:用于设定该变量是用来接收实参数据的，即“传入”，默认是in
        out：用于设定该变量是用来“存储存储过程中的数据”的，即“传出”，即函数中必须对其赋值
        inout：是in和out的结合
        对于out和inout设定，对应的实参必须是一个变量，因为该变量是用于接收“传出”的数据的
    删除存储过程：drop procedure 存储过程名
##  php中使用存储过程和存储函数
```php
    // 调用存储函数：
    $v1 = $_POST['a'];
    $v2 = $_POST['b'];
    $sql = "insert into tab1(id, f1, f2) values(null, now(), func1($v1, $v2));";
    $result = mysql_query($sql);

    // 调用存储过程
    $v1 = $_POST['username'];
    $v2 = $_POST['password'];
    $v3 = $_POST['age'];
    $sql = "call insert_user($v1, $v2, $v3);";
    $result = mysql_query($sql);

    $id = $_GET['id'];
    $sql = "call get_user_info($id)";
    $result = mysql_query($sql);
```
##  触发器
    触发器（trigger）：
        含义：触发器也是一段预先定义好的代码块，跟存储函数和存储过程一样，但不能被调用，而是在某表发生某个事件（增删改）的时候自动触发
        定义形式：
            create trigger 触发器名 触发时机 触发事件 on 表名 for each row as
                begin
                    // 内部语句
                end;
        说明：
            触发时机只有两种：before（在......之前），after（在......之后）
            触发事件只有三种：insert，update，delete
            触发器的含义是在某个表进行触发事件的之前或之后的时候去执行其中写好的代码，每个表只有6种情形可能调用触发器
            通常，触发器用于在对某个表进行增删改的操作的时候，需要同时去做另外一件事情的时候，就可以把这件事设置在触发器里
            在触发器内部有两个关键字代表特定的含义，可以用来获取数据：
                new：代表当前正要执行的insert或update的时候的“新行”数据，通过它可以获取这一行数据的任意一个字段：set @v1 = new.id
                old：代表当前正要执行的delete的时候的“旧行”数据，通过它可以获取这一行数据的任意一个字段：set @v1 = old.id
##  三表查询作业
    TODO
#   13
    学习第十三天的知识
##  day12复习
    TODO
##  day12作业
    TODO
##  面向对象思想介绍
    面向过程编程：
        基本特征：将要完成的任务分割为若干个步骤
    面向对象编程：
        基本特征：将任务分派给不同的对象去执行
    OOP：Object Oriented Program（面向对象编程）
##  面向对象和面向过程完成同一任务的模式
    TODO
##  基本概念：类和对象
    TODO
##  属性和方法
    TODO
##  创建对象的几种形式
    TODO
##  对象的传值方式
    TODO
##  类中成员概述
    面向对象编程是需要通过“对象”完成某种任务，对象总是来源于类，所以面向对象的编程一切都是从定义类开始
    类中成员分为三大类：
        属性：
            普通属性
            静态属性
        方法：
            普通方法
            静态方法
            构造方法
            析构方法
        常量：
    形式上：
        class 类名 {
            常量定义
            属性定义
            方法定义
        }
##  类常量
    当在一个类中定义一个常量时，该常量就是类常量，本质还是常量
    定义形式：
        class 类名 {
            const 常量名 = 常量值; // 不可使用define()定义
        }
    使用形式：常量的使用，是通过类名，并使用范围解析符号"::"来取用的
        类名::常量名
##  实例属性和静态属性
    普通属性（实例属性）：
        实例的单词：instance
        实例其实也叫对象
        普通属性就是一个属性，它可以在该类实例化出的对象上使用的属性
        定义形式：
            class 类名 {
                var $属性名 = 值;
                var $属性名; // 这个属性没有初始值
                // 上述的var可以用public代替，一般都是用public
            }
        使用形式：
            是通过该类的对象，来使用普通属性：
                $对象->属性名
            因为属性的本质就是变量，则其就可以当作一个变量来看待和使用，如：
                $v1 = $对象->属性名
                $对象->属性名 = 值
    静态属性：
        静态属性本质上也是变量，但该属性只隶属于类，即一个类种的一个静态属性，只有一份数据，但一个类中的实例属性就可以有多分数据，每创建一个对象出来就多了一份数据
        定义形式：
            class 类名 {
                static [public] $属性名 = 初始值;
                static [public] $属性名;
            }
        使用形式：
            使用类名和范围解析符来对静态属性进行操作：
                类名::$静态属性名
            实例属性是每个对象独立的，静态属性是每个对象共用的
##  实例方法和静态方法
    普通方法（实例方法）：
                }
            }
        调用形式：
            $对象名->方法名(实参1, 实参2, ...)
    静态方法：
        定义形式：
            class 类名 {
                static function 方法名(形参1, 形参2, ...) {
                    // 方法体
                }
            }
        调用形式：
            类名::静态方法名(实参1, 实参2, ...)
    $this->：代表调用当前方法的对象
    self::：代表当前类
    注意：静态方法通常调用不了实例属性，实例方法可以通过（self::）调用静态属性
##  构造方法
    构造方法：
        __construct
        构造方法是一个特殊的方法：
            名字是固定的：__construct
            该方法通常都不要我们自己调用，而是在new一个对象的时候自动调用
            该方法主要的目的是为了在new一个对象的时候，给该对象设置一些初始值（初始化工作）
        定义形式：
            class 类名 {
                function __construct(形参1, 形参2, ...) {
                    // 方法体
                }
            }
        调用形式：
            $a = new 类名(实参1, 实参2, ...)
##  析构方法
    析构方法：
        __destruct
        析构方法是一个特殊的方法，名字为固定的词：__destruct
        析构方法是在一个对象被销毁的时候会自动调用的方法，人为无法调用
        析构方法不能设置形参，但方法中也可以使用static，代表当前对象
        定义形式：
            class C1 {
                public $name;
                function __contruct($n){
                    $this->name = $n;
                }
                function __destruct(){
                    // 方法体
                }
            }
        调用形式：
            $a = new C1('小红');
##  对象销毁的时机
    脚本程序运行结束后，所有的对象都会被销毁，对象销毁的顺序默认情况下与对象被创建的顺序相反
    对象可以提前被销毁，通过unset($对象名);
    通过值传递的方式，将旧对象名传给新对象名，unset旧对象并不会销毁对象本身
    通过引用传递的方式，将旧对象名传给新对象名，unset旧对象并不会销毁对象本身
#   14
    学习第十四天的知识
##  day13复习
    TODO
##  day13作业
    TODO
##  继承的基本概念
    将一个类A中的特性信息传递给另一个类B中，此时就是类B继承类A，类A派生类B
    继承：一个类从另一个已有的类中获得其特性，称为继承
    派生：从一个已有的类产生一个新的类，称为派生
    父类/子类：已有类为父类，新建类为子类，父类可以称为基类，上级类，子类可以称为派生类，下级类
    单继承：一个类只能从一个上级类继承其特性信息，PHP和大多数面向对象语言都是单继承模式
    扩展：在子类中再来定义自己的一些新的特性信息
##  访问控制修饰符
    用来限制其所修饰的成员的可访问性，有三种：
        public：公共的，在所有位置都可访问（使用）
        protected：受保护的，只能在该类内部和该类的子类或父类中访问（使用）
        private：私有的，只能在该类内部访问（使用）
    有三个访问位置（范围）：
        某个类的内部
        某个类的继承类的内部
        某个类的外部
##  访问控制修饰符举例
    TODO
##  parent关键字
    TODO
##  构造方法和析构方法的继承与调用问题
    如果一个类有构造方法，则实例化这个类的时候，就不会调用父类的构造方法
    如果一个类没有构造方法，则实例化这个类的时候，如果父类有构造方法就会调用
    如果一个类中有析构方法，则销毁这个类的时候，就不会调用父类的析构方法
    如果一个类没有析构方法，则销毁这个类的时候，就会自动调用父类的析构方法
    如果一个类中有构造方法或析构方法，则就可以去“手动”调用父类的同类方法
##  覆盖基本概念
    覆盖：override，又叫“重写”，将一个类从父类中继承过来的属性和方法“重新定义”，此时相当于子类不想用杜磊的该属性或方法，而是想要定义
    覆盖的现实需要：
        对于一个父类，或许其树形的现有数据（值），子类觉得不合适，而需要由自己的新的描述；
        或许其方法，子类觉得不合适，需要自己来重新定义该方法中要做的事
##  覆盖的细节要求
    重写的基本要求：
        访问控制权限：
            子类覆盖的属性或放啊的访问控制权限，不能“低于”父类的被覆盖的属性或方法的访问控制权限
            具体来说：
                父类：public 子类：只能是public
                父类：protected 子类：public或protected
                父类：private 子类：不能覆盖
        方法的参数形式：
            子类覆盖父类的同名方法的时候，参数要求跟父类保持一致
        注意：
            虽然父类的私有属性不能被覆盖，但子类却可以定义自己的同名的属性（与父类没有关系）
            虽然父类的私有方法不能被覆盖，但子类也不能定义自己的同名的方法
##  最终类
    最终类，其实就是一种特殊要求的类，要求该类不允许被继承
    形式：
        final class 类名 {
            // 类的成员定义
        }
##  最终方法
    最终方法：就是不允许下级类区覆盖的方法
    形式：
        class 类名 {
            final function 方法名(...){......}
        }
##  设计模式、工厂模式
    什么叫设计模式？
        简单来说，设计模式就是解决某个问题的一般性代码的经验性总结，
        类比来说：
            它类似之前所学的“算法”，针对某种问题，使用某种特定的语法逻辑就可以完成该任务
    工厂模式：
        所谓工厂模式，就是一个可以根据“传递”给它的类，而去生产出对应的类的对象的工厂类。
##  单例模式
    例，就是实例（Instance），其实就是对象（Object）
    单例：就是一个对象
    单例模式：就是设计这样一个类，这个类只能“创造”出它的一个对象（实例）
##  mysql数据库操作类（1）
    TODO
##  mysql数据库操作类（2）
    TODO
#   15
    学习第十五天的知识
##  day14复习
    TODO
##  day14作业
    TODO
##  抽象类和抽象方法的基本概念
    抽象类
        是一个不能实例化的类
        定义形式：
            abstract class 类名{......}
        为什么需要抽象类：
            它是为了技术管理而设计
    抽象方法：
        是一个只有方法头，没有方法体的方法
        父类定义了抽象方法后，子类必须完成该抽象方法的方法体
##  抽象类和抽象方法的细节
    一个抽象方法，必须在抽象类
    放过来，抽象类中可以没有抽象方法
    可见，抽象方法是为了规定子类中必须要做什么
    下级类中继承了上级类的抽象方法，则要么去“实现该方法的具体内容”，要么自己也作为抽象类（即其继承的抽象方法仍然是抽象的）
    子类实现父类的抽象方法的时候，其形参也应该跟父类保持一致，其访问权限不能变小
##  重载概念
    重载技术
        重载在“通常面向对象语言”中的含义：
            是指，在一个类（对象）中，有多个名字相同但形参不同的方法的现象
            class C{
                function f1(){}
                function f1($p){}
                function f1($p1, $p2){}
            }
            重载在“php”中的含义：
                是指，当对一个对象或类使用其未定的属性或方法的时候，其中的一些“处理机制”
##  重载简单示例：属性重载
    取值：__get
    赋值：__set
    判断：__isset
    销毁：__unset
##  __get、__set魔术方法
    __get(属性名)：
        当对一个对象的不存在的属性取用时就会自动调用这个方法
    __set(属性名，值)：
        当对一个对象的不存在的属性进行“赋值”的时候，就会自动调用这个内部的魔术方法，它有两个形参，分别代表要对不存在的属性进行赋值的时候的“属性名”和“属性值”
##  __isset、__unset魔术方法
    __isset(属性名)：
        当对一个对象的不存在的属性进行isset()判断的时候，就会自动调用魔术方法__isset()
    __unset(属性名)：
        当对一个对象的不存在的属性进行unset()操作的时候，就会自动调用魔术方法__unset()
##  方法重载
    当对一个对象的不存在的实例方法进行“调用”的时候，会自动调用类中的__call()这个魔术方法
    当对一个对象的不存在的静态方法进行“调用”的时候，会自动调用类中的__callstatic()这个魔术方法
##  使用php重载技术实现通常的方法重载
    TODO
##  接口初步
    什么是接口？
        先看抽象类：
            abstract class 类名 {
                属性;
                .......
                
                非抽象方法;
                .......
                
                抽象方法;
                .......
            }
            设想，将上述抽象类中非抽象的成员删除，则该抽象类中就只有抽象成员：
            abstract class 类名 {
                抽象方法;
                .......
            }
            由此，这个抽象类几乎自己什么都没有做，只是规定了继承类一定要做什么
            那么：
            接口就是这样一个“抽象”的东西：
                接口，就是规定，里面只能做“抽象方法”和“常量”的一种类似类的结构体
                可见，接口就是“比抽象类更抽象的”一种语法结构
    接口（interface）定义形式：
        interface 接口名 {
            常量1;
            ......
            
            抽象方法;
            ......
        }
        说明：
            可见，接口中，只有常量（接口常量）和抽象方法两种成员
            接口常量的使用形式为：接口名称::常量名称
            接口中的抽象方法，不要使用abstract修饰，也不要使用访问控制修饰符，因为其天然是public
##  接口应用举例
    为什么需要接口？
        面向对象编程思想是对“现实世界”的描述
            现实世界往往都是更多继承的
        但是
            出于降低类与类之间的复杂度的考虑，就将语言设计为单继承的
        但这样，就无法表达出现实世界的多继承特性
        则：
            接口就是对没有多继承的类之间关系的一个补充
        因为：接口可以实现“多继承” —— 但此时不称为继承而已，而是称为实现
            即：
                接口 -> 类
            就称为：类实现了接口
                其本质，就是类中有了接口中的特征信息
##  类和接口的大总结
    TODO
##  mysql工具类的优化
    TODO
##  mysql工具类的应用方法
    TODO
#   16
    学习第十六天的知识
##  day15复习
    TODO
##  day15作业讲解
    TODO
##  mysql工具类改进：优化语句执行
    TODO
##  mysql工具类改进：单例化
    TODO
##  类的自动加载
    含义：当某行代码需要一个类的时候，php的内部机制可以做到“自动加载该类文件”，以满足该行需要一个类的需求
    什么时候需要一个类？
        new一个对象的时候
        使用一个类的静态方法的时候
        定义一个类（A）并以另一个类（B）作为父类的时候
    形式：
        __autoload(类名（同时等于文件名）)
    条件和要求：
        当需要一个类的时候，就会自动调用某个函数（默认是__autoload）并传入所需要类的名字
        一个类应该保存到独立一个类文件中，即其中只有该类的定义，没有别的代码
        习惯上，类文件的命名要有一定的规则，通常是：类名.class.php
        在该自动加载的函数中，充分使用传过来的类名，以构建一个合适的文件路径并载入
        通常把类文件集中存储在指定的目录中，以方便统一载入
    自定义自动加载函数：
        __autoload()函数是php系统自带的自动加载函数，魔术方法
        可以使用更多的（自定义）函数来实现更灵活的自动加载
        基本模式为：
            spl_autoload_register("函数1") // 声明函数1为自动加载函数
        spl_autoload_register()是php系统自带的用于声明某个函数是自动加载函数的函数
##  对象的复制（克隆）
    $obj1 = new A();
    $obj2 = $obj1;
    这其实只有一个对象，两个变量指向同一个对象（对象的传值）
    $obj3 = &$obj1;
    也是只有一个对象（对象的引用）
    克隆对象：就是复制出一个新的独立的对象
    $obj4 = clone $obj1;
    克隆出新对象
##  对象遍历
    对象的遍历与数组的遍历一样
    foreach(对象名 as $key => $value) {
        
    }
    注意：
        只能遍历出对象的“实例属性数据”，方法和静态属性不能遍历
        $key表示对象的属性，$value是其对应值
        这里能够遍历出来的属性只能是在该范围中的“可访问属性”（就是要考虑访问控制权限）
        在类的内部对类自身遍历是可以把所有的属性遍历出来的
##  内置标准类
    php语言内部，有“很多现成的类”，其中有一个被称为“内置标准类”
    这个类“内部”可以认为什么都没有，类似这样：
        class stdclass{}
    作用是存储一些临时的对象属性
##  转换为对象类型
    其它数据类型转换为对象类型：
        得到的结果是：内置标准类的一个对象
    语法形式：
        $obj1 = (object) 其它数据类型
    null转为对象，对象是空对象
    数组转换为对象，数组的键名是对象的属性名，值为对应的值
        数字下表的数组不推荐转换为对象，因为无法通过对象语法获取
    其它标量数据类型转换为对象后，其属性固定为“scalar”
##  类型约束
    什么是类型约束？
        就是要求某个变量只能使用（接收、存储），某种特定的数据类型
        php属于“弱类型语言”，通常不支持类型约束
        相应的，强类型语言，类型约束却是其“基本特征”
    php中，只支持局部的部分类型约束
        php中，只支持在函数（或方法）的形参上，设定类型的约束目标，形式如下：
            function 方法名([要求使用的类型] $p2, ......) {}
        说明：
            一个形参，可以使用类型约束，也可以不使用
            如果使用了类型约束，则实参数据，就必须是要求的那种类型
            能够使用的类型约束，其实非常少：
                数组：array
                对象：使用类的名称，表示，传递过来的实参，必须是该类的实例
                接口：使用接口的名称，表示传递过来的实参，必须是实现了该接口的类的实例
##  单例类的加强：禁止克隆
    单例类会被clone方式克隆
    __clone魔术方法，在对象被clone之前都会自动调用这个方法，只要私有化__clone这个方法，就可以禁止clone
##  数据的序列化
    序列化与反序列化技术
        序列化：就是将一个变量所代表的内存数据，转换为字符串形式并持久保存在硬盘上的一种做法
        反序列化：就是将序列化之后保存在硬盘上的字符串数据，恢复为其原来的内存形式的变量数据的一种做法
        序列化的做法：
            $a = 123;
            $b = serialize($a); // 将变量数据转为字符串
            file_put_contents('要保存的目标文本文件', $b); // 存储硬盘文件中
        反序列化的做法：
            file_get_contents('目标文本文件');
            $b = unserialize($a); // 将变量数据转为字符串
##  对象的反序列化
    对象的序列化：
        对一个对象进行徐璐护额，只能将其属性数据“保存起来”，而方法被忽略（方法不是数据）
        对象的序列化的时候，会自动调用该对象所属类的这个魔术方法：__sleep()
    对象的反序列化：
        对一个对象进行反序列化，其实就是恢复其原来保存起来的属性数据，而且，此时必然需要依赖该对象原本的所属类
        对象在反序列化的时候，会自动调用该对象所属类的这个魔术方法：__wakeup()
##  __tostring和_invoke魔术方法
    __tostring()：
        将一个对象“当作一个字符串来使用的时候，会自动调用该方法，并且在该方法中，可以返回一定的字符串，以表明该对象转换为字符串之后的结果
        注意：
            如果没有定义该方法，则对象无法当作字符串来使用
    __invoke()：
        将对象当作函数来使用的时候，会自动调用这个方法
##  零碎的常量、函数和运算符
    与类有关的魔术常量：
        __FILE__
        __DIR___
        __LINE__
        __CLASS__：当前所在的类名
        __METHOD__：当前所在的方法名
    与类有关的系统函数：
        class_exists()：判断一个类存不存在
        intetface_exists()：判断一个接口存不存在
        get_class($obj)：获取指定对象所属的类
        get_parent_class()：获取对象的所属类的父类
        get_class_method()：获取一个对象的所有方法名，结果是一个数组
        get_class_vars()：获取一个对象所有属性名
        get_declared_classes()：获得“整个系统”所定义的所有类名
    与对象有关的系统函数：
        is_object()：判断某个变量是否是一个对象
        get_object_vars()：获得一个对象的所有属性，结果是一个数组，里面存储的是这些属性的名称
    与类有关的运算符：
        new：
        instanceof：判断一个变量是否是某个类的实例
##  static关键字的使用
    static这个关键字，也可以像“self”一样，代表“当前类”，用于访问一个类的“静态属性或静态方法”，但static在应用中，更灵活，因此更常见！
    因为static，它代表的是“调用”当前方法的类，而不是“其代码所在的类”：
        self它就比较死板，只代表这个单词本身所在位置的所在类
##  面向对象3大思想
    封装：
        无非是一个大的指向思想，目的是为了将一个类设计得更为健壮！
        其基本做法是：
            尽可能地将一个类的成员私有化，只开放那些必不可少的对外的属性或方法，能private的就不要protected，能protecred的就不要public
    继承：
        是面向对象的基本思想和基本做法
        继承是代码重用的一种重要机制
    多态：
        就是多种状态，其实指的是现实世界的丰富多彩的表现形式
        不同对象，使用相同的方法，会表现为不同的结果
        同一个对象，使用相同的方法，也可能会表现为不同的结果
#   17
    学习第十七天的知识
##  day16复习
    TODO
##  项目开发流程介绍
    需求调研：
        成果：需求说明书
    软件设计：
        成果：详细设计说明书 —— 通常这就是开发过程中的主要参考文档
    界面设计：
        成果：设计效果图
    静态网页制作：
        成果：静态页面
    动态网页开发：
        成果：基本可用的软件初级产品
    测试：
        成果：可用的符合需求的产品
    上线运营：
        成果：发现问题，提出改进需求，稳定上线
##  显示与逻辑相分离思想
    TODO
##  模板技术
    TODO
##  mvc思想简单演示
    TODO
##  mvc思想框架原理图
    TODO
##  mvc典型演示：数据模型
    TODO
##  mvc典型演示：控制器文件
    TODO
##  mvc典型演示：视图文件
    TODO
##  模型层的主要作用
    用于处理数据的存取操作，比如表的增删改查
    通常都是根据“控制器的要求”，以返回合适的数据
##  模型层的典型代码模式
    TODO
##  控制器中调用模型层获取数据的典型做法
    TODO
##  基础模型类
    TODO
##  基础模型类 —— 调试成功
    TODO
##  实现模型类的单例：单例工厂类
    TODO
##  模型类的整体类库结构图
    TODO
##  使用mvc框架模式完成删除功能
    TODO
#   18
    学习第十八天的知识
##  day17复习
    TODO
##  功能：显示用户详细
    TODO
##  控制器的作用：继续完成新功能“添加用户”
    TODO
##  控制器类的“来源”
    TODO
##  用户资料修改功能
    TODO
##  产品控制器
    TODO
##  控制器类的常见做法
    TODO
##  基础控制器类
    TODO
##  视图层的典型做法
    TODO
##  请求分发器（前端控制器）
    TODO
#   19
    学习第十九天的知识
##  day18复习
    TODO
##  目录结构的设定
    通常，我们会将一个MVC项目中的一些相应的文件，分门别类存放，结果类似：
        MVC项目：
            index.php // 入口文件
            /Controller // 控制器文件夹
            /Model // 模型类文件夹
            /View // html视图文件夹
            /Common // 公共文件
##  新功能：产品删除
    TODO
##  有关平台的观念和目录设定
    TODO
##  演示新建一个平台：后台
    TODO
##  常见常量的设定及应用
    TODO
##  自动加载的实现
    TODO
##  禁止访问其他目录
    TODO
##  ecshop安装
    TODO
##  设计登录界面
    TODO
##  登录功能的实现
    TODO
##  pdo对象
    PDO是别人写的“数据库操作工具类”，可以代替我们自己写的MySQLDB.class.php
    如：
        $pdo = new PDO(连接信息);
        $sql = "...";
        $result = $pdo->query($sql);
    $pdo->commit()：提交一个事务
    $pdo->rollBack()：回滚一个事务
    $pdo->inTransaction()：判断当前行是否在事务中，true/false
    $pdo->setAttribute(属性名, 属性值)：设置pdo对象的属性
##  pdo对象的常用方法
    TODO
##  pdo的预处理语法
    TODO
#   20
    学习第二十天的知识
##  login动作执行流程
    TODO
##  checkLogin的执行流程
    TODO
##  后台首页动作
    TODO
##  登陆标识判断的流程分析
    TODO
##  如何存储登录标识的测试分析
    TODO
##  什么是会话技术
    在同一台浏览器的多次请求周期内持久性存储数据的一种技术
    两种实现：
        Cookie
        Session
##  cookie的基本原理
    TODO
##  cookie的基本操作
    setcookie(属性名, 属性值, 存储时间, 有效路径, 域名)：设置cookie属性
    $_COOKIE[属性名]：获取指定cookie属性的值
##  cookie的有效期属性
    默认浏览器关闭（会话周期结束）时COOKIE也会失效，称之为临时COOKIE
    允许设置COOKIE的有效期，语法上，使用setcookie第三个参数来进行设置
    
    特殊值：
        PHP_INT_MAX：PHP最大整数
        time() - 1：将有效期强制设为过期
        
    删除cookie的方法：
        设置属性的值为空，则有效期变为1970年（语法糖）
##  有效路径
    设置路径为'/'，则该cookie整站有效，使用setcookie第四个参数来进行设置
##  有效域名（二级域名有效）
    有效域：
        默认的，在某个域名下设置的cookie，只有该域名下可以使用
        
    设置有效域为'.xxx.com'，则该cookie在这个域名下都有效，使用setcookie第五个参数来进行设置
##  安全相关的属性
    https：
        是否仅安全连接：
        告知浏览器，我们所设置的cookie，是否仅仅在https这个写一下，才会被发送到浏览器端
        使用setcookie第五个参数来进行设置，true/false
    HTTPONLY：
        所设置好的cookie是否仅仅在http请求时所用
        因为cookie还可以通过浏览器端的脚本获取到
        使用setcookie第六个参数来进行设置，true/fasle
##  cookie语法细节和常见使用
    TODO
##  session技术的基本原理
    Cookie的劣势：
        会话数据的存储位置在浏览器，安全性较差
        请求（响应）传输的数据量大，因此浏览器限制cookie的大小和数量
    Session技术：
        会话数据的存储位置在服务器端，安全性较高
    那么如何实现区分不同的浏览器来存储会话数据：
        在服务器端，建立很多的会话数据区（Session数据区）
        为每个session会话数据区分配唯一标识
        将该唯一标识分配给对应的会话浏览器
##  session的基本使用
    开启session机制：
        session_start()：
            开启后，所有关于session机制（生成session_id）都由session机制完成
    操作session数据：
        $_SESSION超全局变量
##  session的ID和服务器端会话
    TODO
##  session完成登录标识存储 - 登录验证
    TODO
##  管理员信息作为标识
    TODO
#   21
    学习第二十一天的知识
##  上天回顾
    TODO
##  语法细节注意
    TODO
##  session的属性
    有效期：
        默认关闭浏览器的时候国企
    有效域名：
        默认在当前域名下有效
    session属性的来源：
        cookie种存储的session-id的属性，决定了对应的session数据的属性
    如何设置session数据的属性：
        设置cookie中session-id这个cookie属性即可：
            配置php.ini中的属性：
                session.cookie_lifetime：有效期
                session.cookie_path：有效路径
                session.cookie_domain：有效域
                session.cookie_secure：安全链接
                session.cookie_httponly：是否为httponly
            通过ini_set函数设置上述属性
            通过session_set_cookie_params(有效期, 有效路径, 有效域)设置
        先配置再开启
##  session数据区的操作
    Session数据区：
        默认以文件的形式存储于服务器操作系统临时目录中
        当session数据区过多时，文件形式的存储，操作速度变慢
    Session数据区的操作：
        TODO
##  session入库的实现 - 结构
    重写session数据区机制读写操作：
        1、定义两个可以完成读写的函数
        2、告知session机制，在需要读写时，使用用户自定义的读写函数（session_set_save_handle）
    session_set_save_handle(开始函数, 结束函数, 读函数, 写函数, 删除函数, GC函数)
##  session入库 - 表结构
    TODO
##  读写操作的完成
    TODO
##  session销毁
    TODO
##  垃圾回收
    垃圾：服务器上过时的session数据区
    如何判定？
        如果一个session数据区已经超过多久没有使用（最后一次写操作）了，就是被视为垃圾数据
        该时间的临界点默认是1440s，在php.ini中配置session.gc_maxlifetime
    如何删除？
        在session_start过程中，开启session机制过程中，有几率地执行垃圾回收操作，一旦执行，就会删除所有的过期的数据区
    如何设置触发概率？
        默认是千分之一的概率，可以在php.ini中设置session.gc_probability（可能性、分子）和session.gc_divisor（分母）
##  开启和结尾函数
    TODO
##  几个语法细节
    先设置session配置，再开启session机制，不要自动开启
    php配置项：session.save_handler：
        php所使用的默认存储机制：files（以文件方式存储）
        若自定义session配置，则建议将默认存储机制改为user
##  常见问题总结
    相关配置
        session.sava_handler：存储处理器（files|user）
        session.cookie_xxx（lifetime|path|domain|......）
        session.gc_maxlifetime
        session.gc_probability
        session.gc_divisor
        session.save_path
    session和cookie联系和区别？
        都是会话技术
        session基于cookie，session-id存储与cookie中
        区别：
            cookie：存储在浏览器端，安全性低，有大小限制，数据类型只支持字符串，长时间有效期存储
            session：存储在服务器端，安全性较高，没有大小限制，支持全部数据类型，几乎不做持久化
        session如何持久化？
            session-ID要持久化：session_set_cookie_params(3600);
            服务器session数据区有效期增加：修改ini_set('session.gc_maxlifetime', 3600)
        浏览器禁用cookie，session是否可用？
            cookie被禁用，session-id不能存储和传输，所以不可用
            理论上的解决方案：
                通过url或者post数据向服务端传输session-id
                修改一下配置：
                    session是否仅仅使用cookie完成session-id的传输：session.use_only_cookies = 1（是）
                    是否通过其它方式传输session-id：session.use_trans_sid = 0 （否）
##  后台页面的展示
    TODO
##  项目中实现集中登录校验
    TODO
#   22
    学习第二十二天的知识
##  上天回顾
    TODO
##  记录登录状态功能分析
    TODO
##  记录状态
    TODO
##  验证登录状态的存储
    TODO
##  验证码概述
    TODO
##  php处理图片的典型步骤
    使用GD扩展，开启php.ini中的gd2.dll扩展
    创建画布资源：
        创建新的画布：
            imagecreate(宽, 高)：创建基于调色板画布（支持的颜色少）
            imagecreatetruecolor(宽, 高)：创建正彩色画布（支持的颜色多）
        基于已有图像创建画布：
            imagecreatefromjpeg(图像路径):            
            imagecreatefrompng(图像路径):
            imagecreatefromgif(图像路径):
    设置画布：
        分配颜色：（为某张画布分配某种颜色）
            imagecolorallocate(画布资源, 颜色R, 颜色G, 颜色B)
        填充画布：（使用某个颜色，在画布的某个位置进行填充）
            imagefill(画布, X坐标, Y坐标, 颜色) // 图片的左上角为原点（0，0），横向向右增加X，纵向向下增加Y
    导出画布：
        imagepng(画布资源, 存储路径):
        imagegif(画布资源, 存储路径):
        imagejpeg(画布资源, 存储路径):
    销毁资源：
        imagedestroy(画布资源)
##  参考ecshop验证码生成
    TODO
##  码值居中
    TODO
##  验证码工具类
    TODO
##  项目中登录验证码
    TODO
##  图片程序的错误处理
    TODO
##  验证码校验
    TODO
##  点击更换
    TODO
##  上传的基本原理
    TODO
#   23
    学习第二十三天的知识
##  上天回顾
    TODO
##  文件上传的典型实现
    需要判断文件：
        是否存在错误
        类型是否符合要求
        大小是否符合要求
        生成合理的文件名
        存储文件到服务器
##  子目录存储上传文件
    划分子目录的方案：
        1、根据不同业务逻辑划分对应存储位置
        2、根据文件数量来划分
        3、根据时间周期来划分
##  文件PHP检测mime和is_uploaded_file
    上传文件的安全性：
        对文件类型的限制：
            $_FILES中的type类型是浏览器检测的，不是PHP检测的
            PHP检测文件的MIME类型：
                fileinfo相关函数（方法）：
                    1、开启fileinfo扩展：php.ini
                    2、$fileinfo = new Finfo(FILEINFO_MIME_TYPE)
                    3、$mime_type = $fileinfo->file(文件)
        对重复文件内容上传的限制：
            1、在保存之前，判断是否是HTTP上传文件
##  多文件上传处理
    TODO
##  错误类型介绍
    TODO
##  几个上传相关的配置
    上传文件数量：max_file_uploads
    post数据大小：post_max_size
##  商品添加表单展示功能
    TODO
##  商品表的创建
    TODO
##  插入商品到数据表
    TODO
##  上传工具类的定义 - 封装性的体现
    TODO
##  使用上传类完成商品图片上传
    TODO
##  目录操作函数1
    创建：mkdir(目录地址,权限，是否递归创建)
    删除：rmdir(目录地址) // 不允许删除非空目录
    获取目录内容：
        opendir()：打开目录句柄（句柄：handle，php程序与文件系统的数据流通道）
        readdir()：通过句柄，从目中读取一个文件（包括文件和子目录），一次读取一个文件，并向下移动文件指针
        closedir()：关闭句柄
##  目录操作函数2
    重命名（移动）：
        rename(原始地址, 目标地址)：针对文件和目录的（将原来的删除，复制并重命名到新的）
#   24
    学习第二十四天的知识
##  上天回顾
    TODO
##  递归获取目录全部内容
    TODO
##  运行基本原理
    TODO
##  树状展示
    TODO
##  将数据存储到数组中
    TODO
##  递归删除
    TODO
##  文件操作基本函数
    unlink(文件地址)：删除文件
    file_exists(文件地址)：文件是否存在
    filemtime(文件地址)：文件最后修改时间
    filesize(文件地址)：文件大小
    file_put_contents(文件地址, 内容, 写入模式)：将内容写入文件
    file_get_contents(文件地址)：将内容从文件中读取
##  文件句柄读写操作函数
    fopen(文件地址, 打开模式)：打开文件句柄，打开模式有r（只读）、w（重写）、a（加写）、x（新建）四种
    fread(文件句柄, 长度)：不受换行符的限制
    fgetc(文件句柄)：每次只读文件中的一个字节
    fgets(文件句柄, 长度)：读取指定长度的字节内容，一次最长读取一行
    fwrite(文件句柄, 写入内容)：在追加模式下，写入位置在读取光标处
    fclose(文件句柄)：关闭文件句柄
    feof(文件句柄)：是否读到最后一个字节
##  文件指针操作
    fseek(句柄, 位置)：定位指针，位置在字节中从0开始
    ftell(句柄)：返回当前指针位置
##  打开模式（留心）
    扩展模式：
        r+：读写（打开任意文件，不存在则新建，文件内容不会被清空，依据文件指针位置进行读写操作，将指针位置后的内容进行替换写）
        w+：读写（打开时清空文件内容，在指针位置进行读写，同样是清空写）
        a+：读写（打开文件不会清空内容，指针只会影响读操作，写操作固定在文件末尾）
        x+：读写（先成功新建文件，依据文件指针位置进行读写操作）
##  文件锁定
    处理文件并发问题的操作：文件锁
    默认的，php文件操作函数不是阻塞状态，是自由操作状态，当需要时，一个脚本操作而需要阻塞另外的脚本操作时，需要用到文件锁
    锁操作流程：
        先加锁，检测锁是否加成功，如果成功再使用
    锁定类型：
        读锁：s-lock，共享锁（其它脚本只读）读操作前，期望增加的锁定，导致，允许并发读，阻塞额外的写操作。
        写锁：x-lock，排他（独占）锁，写操作前，尝试添加的锁定类型，导致其它脚本不能读也不能写。
    意向锁：所有的操作资源的脚本都遵循一个约定来使用文件锁
    flock(句柄, 类型)：用于添加PHP的文件锁定（添加意向锁），类型：LOCK_SH（读锁），LOCK_EX（写锁）
    LOCK_NB：不等待
##  请求格式介绍
    HTTP：
        超文本传输协议
        应用层的协议
        用来规范浏览器与服务器之间的数据交互格式
        规范：
            请求数据格式：
                请求行（request_line）：请求的摘要信息，表示了请求方法、请求资源地址、使用的协议版本
                请求头（request_header）：浏览器向服务器传输的请求属性信息。浏览器需要服务器知道的浏览器的状态
                    user-agent：用户代理，谁发出的这个请求
                    accept-language：请求代理端（浏览器）可以接受的语言类型列表
                    accept：请求代理端可以接收的内容类型列表
                    accept-encoding：请求代理端可以接受的编码类型列表，压缩相关
                    host：请求的主机名
                    connection：连接类型。http/1.1，新标准。响应结束是否立即断开TCP链接，值：keep-alive，短时间内保持链接；close：立即关闭
                    cookie：携带的cookie数据
                    refresh：请求来源路径
                语法上：每行表示一个头，头由标识和内容组成，由冒号分隔，冒号要紧跟标识，行结束时采用回车加换行，头以空行结束
                请求主体（request_body）：
            响应数据格式
##  返回来源页
    TODO
##  多语言展示
    TODO
##  响应结构
    响应行：协议版本 响应状态码 状态消息
        状态码：响应结果与响应消息是一一对应的
            200 ok 成功
            404 not found 访问资源不存在
            403 forbidden 请求被拒绝
            302 found 请求重定向
            500 server internal error 服务器内部错误
    响应头：服务器需要浏览器知道的消息
        date：响应时间
        connection：连接类型
        keep-alive：保持连接的时效
        content-type：主体类型
        content-length：主体的长度（字节）
        set-cookie：设置cookie
    响应主体：
##  控制浏览器缓存
    TODO
##  控制下载
    TODO